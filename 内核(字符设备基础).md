# 1.申请字符设备号
    linux规定每一个字符设备或者块设备都必须有一个专属的设备号。一个设备号由主设备号和次设备号组成。主设备号用来表示某一类驱动。如鼠标，键盘都可以归类到usb驱动中。
    而次设备号是用来表示这个驱动下的各个设备。比如申请第几个鼠标第几个键盘。
    所以，开发字符设备驱动，申请设备号是第一步。只有有了设备号，才可以向系统注册设备。

    设备号 dev_t的数据类型 /home/guoyuge/luckfox-pico/sysdrv/source/kernel/include/linux/types.h 地址
    typedef u32 __kernel_dev_t;

    typedef __kernel_fd_set		fd_set;
    typedef __kernel_dev_t		dev_t;
    typedef __kernel_ino_t		ino_t;
    typedef __kernel_mode_t		mode_t;
    typedef unsigned short		umode_t;

    可以看出来dev_t是u32类型，也就是unsigend int 类型  所以设备号是一个32位数据 高12为主 低20为次设备号
设备号操作宏
    /home/guoyuge/luckfox-pico/sysdrv/source/kernel/include/linux/kdev_t.h 文件地址
    #include <uapi/linux/kdev_t.h>

    #define MINORBITS	20  表示次设备号位数 20
    #define MINORMASK	((1U << MINORBITS) - 1) 用于计算次设备号

    #define MAJOR(dev)	((unsigned int) ((dev) >> MINORBITS))  表示从dev_t中获取主设备号 本质是将dev_t 右移20位
    #define MINOR(dev)	((unsigned int) ((dev) & MINORMASK))   获取次设备号 取低20位的值
    #define MKDEV(ma,mi)	(((ma) << MINORBITS) | (mi))        将主次设备号整合成设备号
    
设备号分配
    设备号分配函数定义在 /home/guoyuge/luckfox-pico/sysdrv/source/kernel/include/linux/fs.h
    中

    静态分配：开发人员自己指定一个设备号，比如选择50设备号作为主设备号，被系统使用过的设备号不可以再使用。可以用cat /proc/devices 再查看哪些已经使用 register_chrdev_region
    动态分配：系统自动给我们一个还没被使用的设备号，这样就避免了冲突问题。alloc_chrdev_region


    register_chrdev_region函数
    函数原型:int register_chrdev_region(dev_t, unsigned, const char *);
    函数参数:
         参数1:设备号的起始值，类型是dev_t。
         比如MKDEV(100,0),表示起始主设备号100,起始次设备号为0。
         参数2:次设备号的数量，表示在主设备号相同的情况下有几个次设备号。
         参数3:设备的名称。
    函数返回值:成功返回0，失败返回值小于0。

    alloc_chrdev_region函数
    函数原型:int alloc_chrdev_region(dev_t*,unsigned, unsigned, const char *);
    函数参数:
        参数1:保存自动申请到的设备号。
        参数2:次设备号的起始地址，次设备号一般从0开始，所以这个参数一般设置成0。
        参数3:要申请的设备号的数量。
        参数4:设备的名字。
    函数返回值:成功返回0，失败返回值小于0。

    unregister chrdev regionk数
    函数原型:extern void unregister_chrdev_region(dev_t,unsigned);
    函数功能:设备号释放函数，注销字符设备以后要释放掉设备号函数参数:
    参数1:要释放的设备号。
    参数2:释放的设备号的数量，

    代码实战
    驱动传参把主设备号和次设备号给驱动
    /home/guoyuge/桌面/linux/dev_t/dev_t.c
    静态分配动态分配都不一样 一般用动态分配 退出记得卸载
# 2.注册字符类设备
    字符设备是用cdev结构体描述一个字符设备， /home/guoyuge/luckfox-pico/sysdrv/source/kernel/include/linux/cdev.h  头文件要包含

        struct cdev {
        struct kobject kobj;
        struct module *owner; //所属模块
        const struct file_operations *ops;//文件操作结构体
        struct list_head list;
        dev_t dev;//设备号
        unsigned int count;
    } __randomize_layout;

void cdev_init(struct cdev *, const struct file_operations *);
用于初始化cdev结构体成员 建cdev和file_operations 之间的关系

int cdev_add(struct cdev *, dev_t(设备号), unsigned(添加设备数量 一般为1));
用于向系统中添加一个cdev结构体，也就是添加一个字符设备

cdev_del(struct cdev *cdev)：只删除 字符设备（cdev），用于与 cdev_add() 成对。
cdev_device_del(struct cdev *cdev, struct device *dev)：是个“组合卸载”辅助函数，同时删除 device 和对应的 cdev，用于与 cdev_device_add() 成对。

    1.先申请字符设备号(一般使用动态)
    2.申请完成后先对cdev结构体进行设置(这个可以不设置) 和file_opertation结构体进行默认配置
    3.进行cdev_init初始化
    4.cdev_add进行添加结构体
    5.卸载的时候一定/* 先删 cdev，再释放设备号 */

add 2. 短答：一般不用改 my_cdev，只改（或完善）file_operations fops 就够了。
    展开说明：
    cdev_init(&my_cdev, &fops) 时，my_cdev.ops 里只保存了对 fops 的指针。cdev_add() 后，打开设备时会用到 inode->i_cdev->ops（也就是你传入的 fops）。
    正确做法是把 fops 定义成 static const struct file_operations，在代码编译期把需要的回调（.open/.read/.write/.unlocked_ioctl/.release/...）都实现好。运行时不要去修改 fops 内容（会有并发/竞态风险）。
    一旦 cdev_add() 完成，不建议再变更 my_cdev 的任何字段（比如换 device number、换 ops 指针等都没有官方 API 支持）。如果确实要改：
    先 cdev_del(&my_cdev)，必要时 unregister_chrdev_region()；
    调整好新的设置（比如新的 fops 或新的设备号）；
    再 register/alloc_chrdev_region()＋cdev_add() 重新注册。
    实践建议：
    需要新增/修改行为 → 在 fops 的各个回调里改代码（编译后重新加载模块）。
    需要在运行时切换行为 → 在回调里做一层自定义分发（例如通过原子变量、RCU 或自旋锁保护的函数指针表/状态机），而不是直接改 fops 或 my_cdev。
    总结：my_cdev 基本只在初始化/注册阶段用 API 设好就行，后续逻辑都靠 fops 各回调实现。

    简短结论：**不是“必须”，但强烈建议用 `const`**。原因有三：

1. 接口约定
   很多内核 API（如 `cdev_init`）的原型是：

```c
void cdev_init(struct cdev *cdev, const struct file_operations *fops);
```

它拿的是 **`const struct file_operations *`**。你的 `fops` 声明成 `static const struct file_operations` 与之匹配，更能体现“这张回调表在运行期不会被改”。

2. 安全 & 并发性
   `const` 会把这张函数指针表放到只读段（`.rodata`），**防止误改**（包括你自己或其它路径无意写入），也避免了多核并发下“谁在改函数表”的风险。驱动的回调表本来就应该是**只读不变**的。

3. 可读性 & 风格
   Linux 内核社区的通用风格就是把各子系统的 `ops` 表写成 `static const ...`，清晰表达“初始化后不可变”的设计意图。编译器还能帮你在误写时直接报错。

补充：

* 从语言规则看，你把 `fops` 写成非 `const` 也能编译通过（因为把“非常量对象的指针”传给“指向常量的指针”形参是允许的）。**但不加 `const` 会让对象落在可写段，增加被误改的可能**，不符合最佳实践。
* 只有在你**确实需要运行时动态改表**（极少见，也不推荐）时才不要 `const`，但那时应在回调内部做状态分发，而不是改 `fops` 本身。

# 3.file_operations 结构体
    一切皆文件，我们可以用open，read,write,close,ioctl 这几个系调用来操作驱动。 当我们应用程序中调用open函数的时候，最终去执行open函数。所以file_operations 将驱动和系统调用连接起来了
    /home/guoyuge/luckfox-pico/sysdrv/source/kernel/include/linux/fs.h
    file_operations 结构体定义

        struct file_operations {
        struct module *owner;               //拥有改结构体的模块指针，一般设置为 THIS_MODULE
        loff_t (*llseek) (struct file *, loff_t, int); //用于修改文件当前的读写位置
        ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); //用于读取设备文件
        ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); //用于向设备文件中写数据
        ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);   
        ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
        int (*iopoll)(struct kiocb *kiocb, bool spin);
        int (*iterate) (struct file *, struct dir_context *);
        int (*iterate_shared) (struct file *, struct dir_context *);
        __poll_t (*poll) (struct file *, struct poll_table_struct *); //轮询函数，用于查询设备是否可以被非阻塞立即读写
        long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); //提供设备相关控制命令的实现
        long (*compat_ioctl) (struct file *, unsigned int, unsigned long); //与unlocked_ioctl功能一样
        int (*mmap) (struct file *, struct vm_area_struct *);//用于将设备内存映射到用户空间去。应用程序可以直接的访问他而无须再内核和应用间进行内存赋值
        unsigned long mmap_supported_flags;
        int (*open) (struct inode *, struct file *); //打开设备文件
        int (*flush) (struct file *, fl_owner_t id);
        int (*release) (struct inode *, struct file *); //释放设备文件
        int (*fsync) (struct file *, loff_t, loff_t, int datasync);
        int (*fasync) (int, struct file *, int);
        int (*lock) (struct file *, int, struct file_lock *);
        ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
        unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
        int (*check_flags)(int);
        int (*flock) (struct file *, int, struct file_lock *);
        ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
        ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
        int (*setlease)(struct file *, long, struct file_lock **, void **);
        long (*fallocate)(struct file *file, int mode, loff_t offset,
                loff_t len);
        void (*show_fdinfo)(struct seq_file *m, struct file *f);
    #ifndef CONFIG_MMU
        unsigned (*mmap_capabilities)(struct file *);
    #endif
        ssize_t (*copy_file_range)(struct file *, loff_t, struct file *,
                loff_t, size_t, unsigned int);
        loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in,
                    struct file *file_out, loff_t pos_out,
                    loff_t len, unsigned int remap_flags);
        int (*fadvise)(struct file *, loff_t, loff_t, int);

        ANDROID_KABI_RESERVE(1);
        ANDROID_KABI_RESERVE(2);
        ANDROID_KABI_RESERVE(3);
        ANDROID_KABI_RESERVE(4);
    } __randomize_layout;


# 4.设备节点
    linux使用一切都是文件操作 每个设备在linux中都有相对应的设备文件，应用程序通过操作这个设备文件，就可以操作对应的硬件设备
                fd=open('dev/hello‘,o_rdwr)
            # 设备文件就是设备节点，linux设备节点是沟通应用程序和驱动程序的一个桥梁
            设备节点在DEV目录下。
            
        crw-------    1 root     root      254,   0 Jan  1  1970 gpiochip0
        这行表示的是一个字符设备文件 `gpiochip0`，它是一个 **GPIO（通用输入输出）设备**。下面是对这一行的详细解析：

```
crw-------    1 root     root      254,   0 Jan  1  1970 gpiochip0
```

    ### 解释：

1. **`c`**：文件类型是 **字符设备文件（character device）**。

   * 字符设备是与硬件设备的交互方式，数据按字符流的方式进行读写（例如键盘、鼠标、串口等设备）。

2. **`rw-------`**：权限位表示：

   * **`rw-`**: 所有者（`root`）有 **读（r）** 和 **写（w）** 权限。
   * **`-------`**: 其他用户（同组和其他用户）没有权限访问此设备文件。

   这意味着 **只有 root 用户** 可以读取和写入该设备。

3. **`1`**：硬链接数。

   * 对于设备文件，硬链接数通常是 `1`，表示这个设备文件在文件系统中的唯一性。

4. **`root`**：文件所有者。

   * 这个设备文件属于 `root` 用户。

5. **`root`**：文件所属组。

   * 这个设备文件属于 `root` 组。

6. **`254, 0`**：主设备号和次设备号。

   * **主设备号（254）**：代表设备类型（`gpiochip`），通常由内核提供给 GPIO 设备。
   * **次设备号（0）**：表示该设备实例的唯一标识符，在系统中可能有多个 GPIO 设备实例（如 `gpiochip1`、`gpiochip2` 等）。

7. **`Jan 1 1970`**：文件最后修改时间。

   * 时间戳可能是默认值或某种系统初始时间，也可能是设备文件在创建设备节点时的时间。

8. **`gpiochip0`**：设备文件名称。

   * 这表示 **第一个 GPIO 设备**，设备文件的名称是 `gpiochip0`。

---

### 背景：GPIO 设备

* **GPIO（General Purpose Input/Output）** 是一种广泛用于嵌入式系统的硬件接口，它允许 CPU 与外部设备进行简单的信号交互。可以配置为输入或输出，并可以用来控制 LED、读取按钮状态、控制电机等。
* 在 Linux 系统中，GPIO 设备通常通过 `/dev/gpiochipX` 文件进行交互，其中 `X` 是 GPIO 设备的编号。
* 设备文件 `gpiochip0` 对应的是第一个 GPIO 设备，你可以通过该设备文件进行 GPIO 操作（如读取或写入 GPIO 引脚的电平状态）。

---

### 操作 GPIO 设备文件

通常，通过打开该设备文件，你可以对 GPIO 设备进行操作（具体操作需要相应的 `ioctl` 调用或通过 `sysfs` 等方式）。但直接操作设备文件时，通常需要用到 `ioctl` 接口来进行配置。

例如，你可以使用 `ioctl` 或者 `sysfs` 操作 GPIO 引脚来进行设备控制。

### 总结

* **设备类型**：字符设备 `gpiochip0`。
* **权限**：只有 `root` 用户可以读写该设备。
* **主设备号**：`254`，表示 GPIO 设备类型。
* **次设备号**：`0`，表示这是第一个 GPIO 设备。
* **文件**：`gpiochip0`，表示一个 GPIO 设备文件。
### linux 可以通过主设备号找到它对应的 file_operations 结构体 通过次设备号找到这个设备是同类设备中的第几个 这样就确定了是哪个应用程序


# linux 下创建节点的方式。
    1.手动创建
    通过命令mknod创建设备节点
    mknod命令格式：
    mknod 设备节点名称 设备类型(字符用c,块设备用b) 主设备号 次设备号 
    例子 mknod /dev/test c 260 0
    2.在注册设备的时候 自动创建
    可以通过 mdev机制实现设备节点的自动创建和删除

    我们来总结一下 
    1.申请设备号
    2.注册设备文件 先声明一个cdev 自己的设备名字（mydev） 然后 用file_operations来修改mydev中的属性一些东西
   
    static const struct file_operations fops = {
    .owner   = THIS_MODULE,
    .open    = my_cdev_open,
    .read    = my_cdev_read,
    .write   = my_cdev_write,
    .release = my_cdev_release,
};
然后再把my_cdev_open my_cdev_read  my_cdev_write my_cdev_release 这几个设备操作一个一个定义 你再系统调用open 或者 read 会执行这几个函数的命令（自己定义的 ）
my_cdev_release对应close
3.在主函数里面     // 初始化 cdev 结构体并注册
    cdev_init(&my_cdev, &fops);
    ret = cdev_add(&my_cdev, dev_num, 1)

最后实验的时候 也就是app 系统编程 来检查 如果你没在注册设备的时候注册设备节点 你就需要用mknod命令 如果你在注册设备的时候就注册了 那就不需要mknod命令
没有注册
[root@luckfox ]# mknod /dev/mychardev c 239 0
[root@luckfox ]# ls /d
data/     dev/      dev_t.ko
[root@luckfox ]# ls /dev/mychardev -al
crw-r--r--    1 root     root      239,   0 Jan  1 00:47 /dev/mychardev
[root@luckfox ]#

rm -f /dev/mychardev  最后直删除就可以

差不多就这样 写完代码最好让ai给自己检查一下 什么的 

# 5 自动创建设备节点
    udev机制 
    linux可以通过udev来实现设备节点的创建和删除，udev是一个用户程序，可以更具系统中的设备的状态进行创建或者删除设备节点，比如当驱动程序成功加载到linux时会自动在/dev 目录下创建相对应的设备节点 驱动程序卸载的时候会自动删除/dev 目录下的节点
    嵌入式linux中我们用的是mdev 是udev的简化版本

  
    设备驱动--------udev------sys/class/xxx   当设备驱动成功加载的时候 会生成 sys/class/xxx  udev会去找sys/class/xxx信息去生成/dev/xxx 设备节点
                    |                                       所以问题就标成了 如果在驱动加载的时候生成 sys/class/xxx  
                    /dev/xxx 设备节点

   class_create在 /home/guoyuge/luckfox-pico/sysdrv/source/kernel/include/linux/device/class.h   这个函数会在sys/class下面创建文件 只是创建类
    #include <linux/device/class.h>   // 提供 class_create 宏/声明
    #include <linux/device.h>         // device_create/device_destroy 等

            #define class_create(owner, name)		\  owner一般设置为THIS_MODLUE  第二个参数name是类的名字sys/class/xxx 也就是xxx
        ({						\
            static struct lock_class_key __key;	\
            __class_create(owner, name, &__key);	\
        })

        extern struct class * __must_check __class_create(struct module *owner,
						  const char *name,
						  struct lock_class_key *key);

    我们用class_create创建好类之后，还需要用device_create函数在下面创建一个设备，
/home/guoyuge/luckfox-pico/sysdrv/source/kernel/include/linux/device.h 在这个路径下
#include <linux/device.h>         // device_create/device_destroy 等

    device_create(struct class *cls, struct device *parent, dev_t devt,
	      void *drvdata, const char *fmt, ...);
    第一个参数 class表示在这个设备创建在哪个类下面 class_create的返回值一般用
    第二个参数 parent是父设备 一般设置为NULL
    第三个参数 dev_t 是设备号
    第四个参数 drvdata是设备可能会用到的数据 一般设置为NULL
    第五个参数 fmt是设备节点的名字

    卸载驱动的时候 对应的删除设备
    void device_destroy(struct class *cls, dev_t devt);
卸载例子
    static void __exit modulecdev_exit(void)
{
    // 按创建逆序清理
    if (my_device) {
        device_destroy(my_class, dev_num);
        my_device = NULL;
        pr_info("Device destroyed\n");
    }
    if (my_class) {
        class_destroy(my_class);
        my_class = NULL;
        pr_info("Class destroyed\n");
    }

    cdev_del(&my_cdev);
    unregister_chrdev_region(dev_num, 1);
    pr_info("cdev deleted and region unregistered\n");
}
必须按照逆序清理
# 字符设备驱动框架
#include <linux/module.h>
#include <linux/init.h>
#include <linux/moduleparam.h>
#include <linux/fs.h>
#include <linux/kdev_t.h>
#include <linux/types.h>
#include <linux/cdev.h>
#include <linux/device.h>         // class_create, device_create 等
// #include <linux/uaccess.h>     // 若后续需要 copy_to_user/copy_from_user 再启用

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Luckfox");
MODULE_VERSION("V1.1");
MODULE_DESCRIPTION("A simple char device driver");

// 1) 模块参数：次设备号起始值
static int minor = 0;
module_param(minor, int, 0644);
MODULE_PARM_DESC(minor, "First minor number of the device");

static dev_t dev_num;
static struct cdev my_cdev;
static struct class *my_class;     // 设备类指针
static struct device *my_device;   // 设备指针

// ---------- file ops ----------
static int my_cdev_open(struct inode *inode, struct file *file)
{
    pr_info("mychardev: open\n");
    return 0;
}

static ssize_t my_cdev_read(struct file *file, char __user *buf, size_t size, loff_t *off)
{
    pr_info("mychardev: read size=%zu pos=%lld\n", size, *off);
    // 这里未向用户空间拷贝数据，返回 0 表示 EOF
    return 0;
}

static ssize_t my_cdev_write(struct file *file, const char __user *buf, size_t size, loff_t *off)
{
    pr_info("mychardev: write size=%zu pos=%lld\n", size, *off);
    // 演示驱动，直接吞掉用户数据并报告全部写入
    return size;
}

static int my_cdev_release(struct inode *inode, struct file *file)
{
    pr_info("mychardev: release\n");
    return 0;
}

static const struct file_operations fops = {
    .owner   = THIS_MODULE,
    .open    = my_cdev_open,
    .read    = my_cdev_read,
    .write   = my_cdev_write,
    .release = my_cdev_release,
};

// ---------- init/exit ----------
static int __init modulecdev_init(void)
{
    int ret;

    // 1) 分配设备号：动态主设备号，次设备号从 module 参数 minor 开始
    ret = alloc_chrdev_region(&dev_num, minor, 1, "mychardev");
    if (ret) {
        pr_err("alloc_chrdev_region failed: %d\n", ret);
        return ret;
    }
    pr_info("Allocated: major=%d minor=%d\n", MAJOR(dev_num), MINOR(dev_num));

    // 2) 初始化并注册 cdev
    cdev_init(&my_cdev, &fops);
   
    ret = cdev_add(&my_cdev, dev_num, 1);
    if (ret) {
        pr_err("cdev_add failed: %d\n", ret);
        goto err_unregister;
    }

    // 3) 创建 class
    my_class = class_create(THIS_MODULE, "mychardev_class");
    if (IS_ERR(my_class)) {
        ret = PTR_ERR(my_class);
        pr_err("class_create failed: %d\n", ret);
        my_class = NULL;
        goto err_cdev_del;
    }

    // 4) 创建设备节点：/dev/mychardev0
    my_device = device_create(my_class, NULL, dev_num, NULL, "mychardev%d", MINOR(dev_num));
    if (IS_ERR(my_device)) {
        ret = PTR_ERR(my_device);
        pr_err("device_create failed: %d\n", ret);
        my_device = NULL;
        goto err_class_destroy;
    }

    pr_info("mychardev: init OK\n");
    return 0;

err_class_destroy:
    class_destroy(my_class);
    my_class = NULL;
err_cdev_del:
    cdev_del(&my_cdev);
err_unregister:
    unregister_chrdev_region(dev_num, 1);
    return ret;
}

static void __exit modulecdev_exit(void)
{
    // 按创建逆序清理
    if (my_device) {
        device_destroy(my_class, dev_num);
        my_device = NULL;
        pr_info("Device destroyed\n");
    }
    if (my_class) {
        class_destroy(my_class);
        my_class = NULL;
        pr_info("Class destroyed\n");
    }

    cdev_del(&my_cdev);
    unregister_chrdev_region(dev_num, 1);
    pr_info("cdev deleted and region unregistered\n");
}

module_init(modulecdev_init);
module_exit(modulecdev_exit);


# 内核空间和用户空间
    liunx把可访问的内存空间分为了两部分，一部分是内核空间，一部分是用户空间。操作系统和驱动程序运行在内核空间(内核态)，应用程序运行在用户空间(用户态)。
    内核空间中的代码控制了硬件资源，用户空间中的代码只能通过内核暴漏的系统调用接口（open,write等）来使用系统中的硬件资源。
    内核空间中的代码偏向于系统管理，用户空间中的代码更偏重业务逻辑(点灯)实现，两者分工不同。

    对硬件的资源的管理都是在内核空间中完成的，应用程序是无法直接对硬件进行操作的，我们只能通过调用内核的接口来完成这样的任务。
    比如应用程序要读取磁盘上的一个文件，应用程序可以向内核发起一个"系统调用"告诉内核:"我要读取磁盘上的文件"。这个过程其实就是通过一个特殊的指令让进程从用户态进入到内核态，
    在内核空间中，CPU可以执行任何的指令，当然也包括从磁盘上读取数据。具体过程是先把数据读取到内核空间中，然后再把数据拷贝到用户空间并从内核态切换到用户态。
    此时应用程序已经从系统调用中返回并且拿到了想要的数据，可以继续往下执行了
    既然进程要从用户空间切换到内核空间才可以使用系统的硬件资源，切换方式有三种:系统调用，软中断，硬件中断。

    1.内核空间和用户空间的数据交换
        内核空间和用户空间的内存是不可以相互访问的，
        /home/guoyuge/luckfox-pico/sysdrv/source/kernel/include/linux/uaccess.h 头文件
        #include <linux/uaccess.h>   // copy_to_user, copy_from_user, get_user, put_user 等
        下面是头文件中的实现
        static __always_inline unsigned long __must_check
        unsigned long copy_to_user(void __user *to, const void *from, unsigned long n)
        {
            if (likely(check_copy_size(from, n, true)))
                n = _copy_to_user(to, from, n);
            return n;
        }
        作用：把内核空间的数据复制到用户空间。
        函数参数： *to是用户空间的指针 *from内核空间的指针 n是从内核空间向用户空间拷贝的字节数。
        函数返回值 成功返回0

        static __always_inline unsigned long __must_check
        copy_from_user(void *to, const void __user *from, unsigned long n)
        {
            if (likely(check_copy_size(to, n, false)))
                n = _copy_from_user(to, from, n);
            return n;
        }
        作用：把用户空间的数据复制到内核空间。
        函数参数： *to是内核空间的指针 *from用户空间的指针 数据的长度。
        函数返回值 成功返回0

  #        #   // 头文件（统一用这个）gpt总结
    #include <linux/uaccess.h>   // copy_to_user, copy_from_user, get_user, put_user

    /*
    * copy_to_user - 从内核复制数据到用户空间
    * @to:   用户空间指针 (void __user *)
    * @from: 内核空间指针 (const void *)
    * @n:    要拷贝的字节数
    * 返回：未拷贝的字节数；返回 0 表示全部成功
    */
    unsigned long copy_to_user(void __user *to, const void *from, unsigned long n);

    /*
    * copy_from_user - 从用户空间复制数据到内核
    * @to:   内核空间指针 (void *)
    * @from: 用户空间指针 (const void __user *)
    * @n:    要拷贝的字节数
    * 返回：未拷贝的字节数；返回 0 表示全部成功
    */
    unsigned long copy_from_user(void *to, const void __user *from, unsigned long n);

    /* 说明：
    * 1) 这些函数在 <linux/uaccess.h> 中内联/宏实现，底层会调用架构相关的拷贝路径，
    *    并配合 access_ok()/check_copy_size()/异常处理，避免直接 memcpy 用户指针的风险。
    * 2) 驱动编写要检查返回值（__must_check）：若非 0，通常返回 -EFAULT 或按已拷字节处理。
    * 3) 标量读写可用 get_user(x, uptr)/put_user(x, uptr)（同头文件）。
    */

//字符设备驱动框架
#include <linux/module.h>
#include <linux/init.h>
#include <linux/moduleparam.h>
#include <linux/fs.h>
#include <linux/kdev_t.h>
#include <linux/types.h>
#include <linux/cdev.h>
#include <linux/device.h>         // class_create, device_create 等
#include <linux/uaccess.h>     // 若后续需要 copy_to_user/copy_from_user 再启用

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Luckfox");
MODULE_VERSION("V1.1");
MODULE_DESCRIPTION("A simple char device driver");

// 1) 模块参数：次设备号起始值
static int minor = 0;
module_param(minor, int, 0644);
MODULE_PARM_DESC(minor, "First minor number of the device");

static dev_t dev_num;
static struct cdev my_cdev;
static struct class *my_class;     // 设备类指针
static struct device *my_device;   // 设备指针

// ---------- file ops ----------
static int my_cdev_open(struct inode *inode, struct file *file)
{
    pr_info("mychardev: open\n");
    return 0;
}

static ssize_t my_cdev_read(struct file *file, char __user *buf, size_t size, loff_t *off)
{
    char kbuf[100]="Hello from kernel space! this is my_cdev_read \n";
    if(copy_to_user(buf, kbuf, sizeof(kbuf))!=0){
        pr_err("copy_to_user failed\n");
        return -EFAULT;
    }
    pr_info("mychardev: read size=%zu pos=%lld\n", size, *off);
    
    return 0;
}

static ssize_t my_cdev_write(struct file *file, const char __user *buf, size_t size, loff_t *off)
{
    char kbuf[100];
    if(copy_from_user(kbuf, buf, size)>0){
        pr_err("copy_from_user failed\n");
        return -EFAULT;
    }
    pr_info("Received from user: %s\n", kbuf);
    pr_info("mychardev: write size=%zu pos=%lld\n", size, *off);
    // 演示驱动，直接吞掉用户数据并报告全部写入
    return size;
}

static int my_cdev_release(struct inode *inode, struct file *file)
{
    pr_info("mychardev: release\n");
    return 0;
}

static const struct file_operations fops = {
    .owner   = THIS_MODULE,
    .open    = my_cdev_open,
    .read    = my_cdev_read,
    .write   = my_cdev_write,
    .release = my_cdev_release,
};

// ---------- init/exit ----------
static int __init modulecdev_init(void)
{
    int ret;

    // 1) 分配设备号：动态主设备号，次设备号从 module 参数 minor 开始
    ret = alloc_chrdev_region(&dev_num, minor, 1, "mychardev");
    if (ret) {
        pr_err("alloc_chrdev_region failed: %d\n", ret);
        return ret;
    }
    pr_info("Allocated: major=%d minor=%d\n", MAJOR(dev_num), MINOR(dev_num));

    // 2) 初始化并注册 cdev
    cdev_init(&my_cdev, &fops);
   
    ret = cdev_add(&my_cdev, dev_num, 1);
    if (ret) {
        pr_err("cdev_add failed: %d\n", ret);
        goto err_unregister;
    }

    // 3) 创建 class
    my_class = class_create(THIS_MODULE, "mychardev_class");
    if (IS_ERR(my_class)) {
        ret = PTR_ERR(my_class);
        pr_err("class_create failed: %d\n", ret);
        my_class = NULL;
        goto err_cdev_del;
    }

    // 4) 创建设备节点：/dev/mychardev0
    my_device = device_create(my_class, NULL, dev_num, NULL, "mychardev%d", MINOR(dev_num));
    if (IS_ERR(my_device)) {
        ret = PTR_ERR(my_device);
        pr_err("device_create failed: %d\n", ret);
        my_device = NULL;
        goto err_class_destroy;
    }

    pr_info("mychardev: init OK\n");
    return 0;

err_class_destroy:
    class_destroy(my_class);
    my_class = NULL;
err_cdev_del:
    cdev_del(&my_cdev);
err_unregister:
    unregister_chrdev_region(dev_num, 1);
    return ret;
}

static void __exit modulecdev_exit(void)
{
    // 按创建逆序清理
    if (my_device) {
        device_destroy(my_class, dev_num);
        my_device = NULL;
        pr_info("Device destroyed\n");
    }
    if (my_class) {
        class_destroy(my_class);
        my_class = NULL;
        pr_info("Class destroyed\n");
    }

    cdev_del(&my_cdev);
    unregister_chrdev_region(dev_num, 1);
    pr_info("cdev deleted and region unregistered\n");
}

module_init(modulecdev_init);
module_exit(modulecdev_exit);


#include<stdio.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<unistd.h>
#include<string.h>

int main()
{
    // 确保路径正确，假设设备文件是 /dev/mychardev
    int fd = open("/dev/mychardev", O_RDWR);  // 用正确的设备节点名称
    if(fd < 0)
    {
        perror("open error");
        return -1;
    }

    char buf[100];
    memset(buf, 0, sizeof(buf));

    // 读取数据
    ssize_t bytes_read = read(fd, buf, sizeof(buf));
    if(bytes_read < 0)
    {
        perror("read error");
        close(fd);
        return -1;
    }
    // 确保 buf 有有效数据
    printf("read buf=%s\n", buf);

    const char *wbuf = "hello kernel";
    
    // 写入数据
    ssize_t bytes_written = write(fd, wbuf, strlen(wbuf));
    if(bytes_written < 0)
    {
        perror("write error");
        close(fd);
        return -1;
    }

    printf("Written %zd bytes: %s\n", bytes_written, wbuf);

    close(fd);
    return 0;
}


自己的理解 首先在app.c也就是系统编程 用户程序中 当 ssize_t bytes_read = read(fd, buf, sizeof(buf));执行的时候 会把对应的fd的用户空间中的数据放在buf中(可能会有溢出问题)
而对于内核空间来说
read会执行下面的代码
static ssize_t my_cdev_read(struct file *file, char __user *buf, size_t size, loff_t *off)
{
    char kbuf[100]="Hello from kernel space! this is my_cdev_read \n";
    if(copy_to_user(buf, kbuf, sizeof(kbuf))!=0){
        pr_err("copy_to_user failed\n");
        return -EFAULT;
    }
    pr_info("mychardev: read size=%zu pos=%lld\n", size, *off);
    
    return 0;
}
会执行这个代码  copy_to_user(buf, kbuf, sizeof(kbuf)) 会把kbuf中的数据也就是内核数据(模拟内核数据),拷贝到用户空间buf中。

当用户程序中   ssize_t bytes_written = write(fd, wbuf, strlen(wbuf));  执行的时候，会把对应的wbuf写入到内核空间中
write会执行下面的代码
static ssize_t my_cdev_write(struct file *file, const char __user *buf, size_t size, loff_t *off)
{
    char kbuf[100];
    if(copy_from_user(kbuf, buf, size)>0){
        pr_err("copy_from_user failed\n");
        return -EFAULT;
    }
    pr_info("Received from user: %s\n", kbuf);
    pr_info("mychardev: write size=%zu pos=%lld\n", size, *off);
    // 演示驱动，直接吞掉用户数据并报告全部写入
    return size;
}
会执行这个代码  copy_from_user(kbuf, buf, size) 会用户空间中的 buf 拷贝到了内核kbuf中


✅ 你的理解非常正确，整体逻辑完全对！我帮你再稍微补充一下底层细节，让你更清晰地理解“用户态 ↔ 内核态”数据流。

---

## 一、用户空间 `read()` 的执行路径

当用户程序执行：

```c
ssize_t bytes_read = read(fd, buf, sizeof(buf));
```

整个过程如下：

1. **进入内核态**：
   系统调用 `sys_read()` → `vfs_read()` → 调用到你注册的字符设备的 `file_operations.read`，
   也就是：

   ```c
   static ssize_t my_cdev_read(struct file *file, char __user *buf, size_t size, loff_t *off)
   ```

   这个函数。

2. **在内核中准备数据**：
   你的驱动中模拟了一段数据：

   ```c
   char kbuf[100] = "Hello from kernel space! this is my_cdev_read\n";
   ```

3. **内核 → 用户 拷贝**：
   `copy_to_user(buf, kbuf, sizeof(kbuf))`

   * 把内核空间中的 `kbuf` 拷贝到用户空间的 `buf`；
   * 这是一个**安全拷贝函数**，会检查用户空间地址是否有效；
   * 如果有问题（比如指针非法、页不可访问），会返回未拷贝的字节数；
   * 如果返回值 ≠ 0，说明拷贝不完整（即失败），所以你判断：

     ```c
     if (copy_to_user(...) != 0)
         return -EFAULT;
     ```

4. **返回到用户空间**：
   用户态的 `read()` 得到拷贝的数据，存在 `buf` 里。

> ✅ 所以你的理解“把内核数据拷贝到用户空间”完全正确。

---

## 二、用户空间 `write()` 的执行路径

当用户程序执行：

```c
ssize_t bytes_written = write(fd, wbuf, strlen(wbuf));
```

流程如下：

1. **进入内核态**：
   `sys_write()` → `vfs_write()` → 调用你驱动的 `file_operations.write`，
   即：

   ```c
   static ssize_t my_cdev_write(struct file *file, const char __user *buf, size_t size, loff_t *off)
   ```

2. **从用户 → 内核 拷贝**：
   你的驱动代码：

   ```c
   char kbuf[100];
   if (copy_from_user(kbuf, buf, size) > 0) {
       pr_err("copy_from_user failed\n");
       return -EFAULT;
   }
   ```

   这里有一个小问题：

   * `copy_from_user()` 返回**未拷贝成功的字节数**；
   * 如果返回值 > 0，表示**拷贝部分失败**；
   * 所以判断应该是：

     ```c
     if (copy_from_user(kbuf, buf, size))
         return -EFAULT;
     ```

   （而不是 `>0`，虽然逻辑效果接近，但语义上更严谨）

3. **打印或处理数据**：
   这时 `kbuf` 里保存了来自用户空间的数据；
   你打印或进一步处理即可。

4. **返回写入的字节数**：
   通常返回 `size`，表示“已全部写入”，即使实际上驱动只是吞掉了数据。

> ✅ 你的理解“用户空间 → 内核空间拷贝”也是完全正确的，只是 `copy_from_user()` 判断可以更严谨一点。

---

## 三、额外说明：为什么要用 `copy_to_user` / `copy_from_user`

用户空间和内核空间地址**不在同一地址空间**，直接 `memcpy()` 会导致内核访问非法内存。
所以必须使用：

* `copy_to_user()`：内核 → 用户；
* `copy_from_user()`：用户 → 内核；

这两个函数底层会：

* 检查用户地址是否合法；
* 做必要的内存页访问处理；
* 遇到错误时安全返回，而不会触发内核崩溃。

---

## ✅ 总结对比表

| 场景  | 数据方向    | 调用函数               | 用户态调用                  | 驱动回调函数            | 内核行为       |
| --- | ------- | ------------------ | ---------------------- | ----------------- | ---------- |
| 读操作 | 内核 → 用户 | `copy_to_user()`   | `read(fd, buf, size)`  | `my_cdev_read()`  | 把内核数据拷贝给用户 |
| 写操作 | 用户 → 内核 | `copy_from_user()` | `write(fd, buf, size)` | `my_cdev_write()` | 把用户数据拷贝到内核 |

---

✅ **总结一句话**：

> 你理解完全正确，只需注意一点：
>
> * `copy_from_user()` 的判断建议写成 `if (copy_from_user(...)) return -EFAULT;`
> * 其它逻辑完全正确，已经是标准的字符设备读写流程。

# 文件私有数据
    文件私有数据就是将私有数据private_data指向设备结构体
    

    然后在read write等函数通过 private_data访问设备结构体 而不是通过 全局变量 来访问
    static dev_t dev_num;
    static struct cdev my_cdev;
    static struct class *my_class;     // 设备类指针
    static struct device *my_device;   // 设备指针
目前这个都是全局变量 如果随着后面都使用全局变量的话 代码就会很复杂 很垃圾 很难看

为了让他规整一些 我们就可以定义一个结构体 就叫做设备结构体

linux中没有明确规定必须使用文件私有数据，但是文件私有数据的使用在linux驱动中广泛应用，其实也体现了面向对象编程的思想



// 字符设备驱动框架 - 稳健版（含并发与越界处理）
#include <linux/module.h>
#include <linux/init.h>
#include <linux/moduleparam.h>
#include <linux/fs.h>
#include <linux/kdev_t.h>
#include <linux/types.h>
#include <linux/cdev.h>
#include <linux/device.h>     // class_create, device_create
#include <linux/uaccess.h>    // copy_to_user, copy_from_user
#include <linux/mutex.h>
#include <linux/string.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Luckfox");
MODULE_VERSION("V1.2");
MODULE_DESCRIPTION("A simple and robust char device driver");

// 模块参数：从哪个次设备号开始分配（单设备时保持为 0 即可）
static int minor = 0;
module_param(minor, int, 0644);
MODULE_PARM_DESC(minor, "First minor number of the device");

#define KBUF_SIZE 100

struct mydev_t {
    dev_t dev_num;            // 设备号
    struct cdev cdev;         // 字符设备对象
    struct class *cls;        // /sys/class 下的类
    struct device *dev;       // /dev 下的设备节点
    char   kbuf[KBUF_SIZE];   // 内核缓冲
    size_t datalen;           // 有效数据长度
    struct mutex lock;        // 并发保护
};

static struct mydev_t mydev;

/* ------------ file operations ------------ */

static int my_cdev_open(struct inode *inode, struct file *file)
{
    file->private_data = &mydev;
    pr_info("mychardev: open\n");
    return 0;
}

static ssize_t my_cdev_read(struct file *file, char __user *buf, size_t size, loff_t *off)
{
    // size_t size 用户请求读取最大的字节数 loff_t *off 文件偏移量  
    struct mydev_t *d = file->private_data; //open的时候把结构体类型为mydev_t的 mydev地址传进来现在取出来以便访问设备缓冲状态
    ssize_t ret = 0;

    mutex_lock(&d->lock);//加锁，防止并发读写引起数据混乱

    // EOF：偏移 >= 数据长度    如果偏移量已经到达或超过了数据长度，说明没有更多数据可读，返回0表示EOF
    if (*off >= d->datalen) {
        ret = 0;
        goto out;
    }

    // 限幅：最多读剩余的 用户请求读取的字节数不能超过剩余的数据长度
    if (size > d->datalen - *off)
        size = d->datalen - *off;

    if (copy_to_user(buf, d->kbuf + *off, size)) {
        ret = -EFAULT;
        goto out;
    }

    *off += size;//文件偏移本次实际读取的字节数 下一次不不会重复读取
    ret = size;

    pr_info("mychardev: read %zd bytes, new pos=%lld\n", ret, *off);

out:
    mutex_unlock(&d->lock);
    return ret;
}

static ssize_t my_cdev_write(struct file *file, const char __user *buf, size_t size, loff_t *off)
{
    struct mydev_t *d = file->private_data;
    size_t space, n;
    ssize_t ret = 0;

    mutex_lock(&d->lock);

    // 不支持在缓冲区末尾之外写入 越界位置检查 如果偏移量大于缓冲区大小，说明写入位置越界，返回错误
    if (*off > KBUF_SIZE) {
        ret = -EINVAL;
        goto out;
    }
    // 计算剩余空间 space 是从当前偏移到缓冲区末尾还能写的字节数。
    space = KBUF_SIZE - *off;
    if (space == 0) {
        ret = -ENOSPC;
        goto out;
    }

    // 实际可写字节  计算本次实际可写字节数 两者取小值
    n = (size > space) ? space : size;

    if (copy_from_user(d->kbuf + *off, buf, n)) {
        ret = -EFAULT;
        goto out;
    }

    *off += n;
    if (*off > d->datalen)
        d->datalen = *off;

    ret = n;

    // 用十六进制打印写入内容（避免字符串未终止导致的越界打印）
    pr_info("mychardev: wrote %zd bytes, new pos=%lld, data(hex, first %zuB): %*phN\n",
            ret, *off, (size_t)min_t(size_t, n, 32), (int)min_t(size_t, n, 32), d->kbuf + (*off - n));

out:
    mutex_unlock(&d->lock);
    return ret;
}

static int my_cdev_release(struct inode *inode, struct file *file)
{
    pr_info("mychardev: release\n");
    return 0;
}

static const struct file_operations fops = {
    .owner   = THIS_MODULE,
    .open    = my_cdev_open,
    .read    = my_cdev_read,
    .write   = my_cdev_write,
    .release = my_cdev_release,
    .llseek  = no_llseek,  // 禁用 lseek，避免 off 被任意修改引发错位/溢出
};

/* ------------ init / exit ------------ */

static int __init modulecdev_init(void)
{
    int ret;

    // 1) 分配设备号（主设备号动态、次设备号从参数 minor 开始）
    ret = alloc_chrdev_region(&mydev.dev_num, minor, 1, "mychardev");
    if (ret) {
        pr_err("alloc_chrdev_region failed: %d\n", ret);
        return ret;
    }
    pr_info("Allocated: major=%d minor=%d\n", MAJOR(mydev.dev_num), MINOR(mydev.dev_num));

    // 初始化内部状态
    mutex_init(&mydev.lock);
    mydev.datalen = 0;

    // 可选：给一个初始读出的内容
    {
        const char *hello = "Hello from kernel space! this is my_cdev_read\n";
        size_t hl = strnlen(hello, KBUF_SIZE);
        memcpy(mydev.kbuf, hello, hl);
        mydev.datalen = hl;
    }

    // 2) 初始化并注册 cdev
    cdev_init(&mydev.cdev, &fops);
    ret = cdev_add(&mydev.cdev, mydev.dev_num, 1);
    if (ret) {
        pr_err("cdev_add failed: %d\n", ret);
        goto err_unregister;
    }

    // 3) 创建 class
    mydev.cls = class_create(THIS_MODULE, "mychardev_class");
    if (IS_ERR(mydev.cls)) {
        ret = PTR_ERR(mydev.cls);
        pr_err("class_create failed: %d\n", ret);
        mydev.cls = NULL;
        goto err_cdev_del;
    }

    // 4) 创建设备节点：/dev/mychardev<minor>
    mydev.dev = device_create(mydev.cls, NULL, mydev.dev_num, NULL,
                              "mychardev%d", MINOR(mydev.dev_num));
    if (IS_ERR(mydev.dev)) {
        ret = PTR_ERR(mydev.dev);
        pr_err("device_create failed: %d\n", ret);
        mydev.dev = NULL;
        goto err_class_destroy;
    }

    pr_info("mychardev: init OK\n");
    return 0;

err_class_destroy:
    class_destroy(mydev.cls);
    mydev.cls = NULL;
err_cdev_del:
    cdev_del(&mydev.cdev);
err_unregister:
    unregister_chrdev_region(mydev.dev_num, 1);
    return ret;
}

static void __exit modulecdev_exit(void)
{
    if (mydev.dev) {
        device_destroy(mydev.cls, mydev.dev_num);
        mydev.dev = NULL;
        pr_info("Device destroyed\n");
    }
    if (mydev.cls) {
        class_destroy(mydev.cls);
        mydev.cls = NULL;
        pr_info("Class destroyed\n");
    }
    cdev_del(&mydev.cdev);
    unregister_chrdev_region(mydev.dev_num, 1);
    pr_info("cdev deleted and region unregistered\n");
}

module_init(modulecdev_init);
module_exit(modulecdev_exit);

使用了设备结构体 同时考虑了溢出问题 

偏移 off 是什么 
off 就是文件读写的当前位置，相当于文件指针（像用户空间 fseek / ftell 那样）。

当用户第一次 read() 或 write() 一个设备文件 /dev/mychardev0 时，
内核会自动把 *off = 0（文件开头）。

每次成功读/写后，你的驱动要手动更新：

*off += 实际读或写的字节数;


这样下一次读/写时，内核会从上次停下来的地方继续。

所以，*off 是跨多次 read/write 调用的上下文状态。


个人发现 其实上面的代码是有点缺陷的 当我们直接open的时候 默认的是从当前偏移*off开始写 而一个新打开的*off初始值一是0 当我们并不是先读而是直接写的时候 我们写入的数据会覆盖掉内核一开始有的数据 hello这一串 ，当我们先read的时候会把这一个fd的*off推到尾部 这时候再写入数据的时候就不会把内核里面的hello覆盖掉。

# 文件私有数据的使用场景
    在linux中，使用主设备号来表示对应的某一类驱动。用次设备号表示这类驱动下的各个设备。
    假如我们现在的驱动要支持主设备号相同，但是次设备号不同的设备。我们就需要使用私有数据private_date.

    container_of 函数 
    函数原型 container_of(ptr,type,member)
    功能 通过结构体变量中某个成员的首地址获得整个结构体变量的首地址
    第一个参数 ptr是结构体变量中的某个成员的地址
    第二个参数 type是结构体的类型
    第三个参数 member是结构体变量的具体名字

    | 名称            | 作用         | 类比          |
| ------------- | ---------- | ----------- |
| `cdev`        | 连接设备号与驱动函数 | “路由表”或“登记卡” |
| `cdev_init()` | 绑定操作集      | “填写表格”      |
| `cdev_add()`  | 注册到内核      | “交表登记”      |
| `cdev_del()`  | 注销设备       | “删除登记”      |
    // 字符设备驱动框架 - 每个 minor 一个 cdev（含并发与越界处理）一个主设备多个次设备
#include<stdio.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<unistd.h>
#include<string.h>

int main()
{
    // 确保路径正确，假设设备文件是 /dev/mychardev
    int fd = open("/dev/mychardev0", O_RDWR);  // 用正确的设备节点名称
    if(fd < 0)
    {
        perror("open error");
        return -1;
    }

    char buf[100];
    memset(buf, 0, sizeof(buf));

    // 读取数据
    ssize_t bytes_read = read(fd, buf, sizeof(buf));
    if(bytes_read < 0)
    {
        perror("read error");
        close(fd);
        return -1;
    }
    // 确保 buf 有有效数据
    printf("read buf=%s\n", buf);

    const char *wbuf = "hello kernel";
    
    // 写入数据
    ssize_t bytes_written = write(fd, wbuf, strlen(wbuf));
    if(bytes_written < 0)
    {
        perror("write error");
        close(fd);
        return -1;
    }

    printf("Written %zd bytes: %s\n", bytes_written, wbuf);

    close(fd);
    return 0;
}
内核代码 
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>

static void hexdump(const unsigned char *p, size_t n) {
    for (size_t i = 0; i < n; ++i) {
        printf("%02X ", p[i]);
        if ((i + 1) % 16 == 0) printf("\n");
    }
    if (n % 16) printf("\n");
}

static ssize_t read_all_until_eof(int fd, unsigned char *buf, size_t cap) {
    size_t total = 0;
    while (total < cap) {
        ssize_t n = read(fd, buf + total, cap - total);
        if (n > 0) {
            total += (size_t)n;
            continue;
        }
        if (n == 0) { // EOF
            break;
        }
        if (errno == EINTR) continue; // 被信号打断，重试
        return -1; // 其他错误
    }
    return (ssize_t)total;
}

static int write_all(int fd, const unsigned char *buf, size_t len) {
    size_t off = 0;
    while (off < len) {
        ssize_t n = write(fd, buf + off, len - off);
        if (n > 0) {
            off += (size_t)n;
            continue;
        }
        if (n < 0 && errno == EINTR) continue;
        return -1;
    }
    return 0;
}

int main(int argc, char **argv)
{
    const char *devpath = (argc >= 2) ? argv[1] : "/dev/mychardev0";
    const char *wbuf = "hello kernel";
    unsigned char buf[1024];

    printf("== Open & read from: %s ==\n", devpath);
    int fd = open(devpath, O_RDWR);
    if (fd < 0) {
        perror("open");
        return 1;
    }

    memset(buf, 0, sizeof(buf));
    ssize_t nread = read_all_until_eof(fd, buf, sizeof(buf)-1); // 预留1字节给 '\0'
    if (nread < 0) {
        perror("read");
        close(fd);
        return 1;
    }
    buf[nread] = '\0'; // 仅用于安全的printf文本视图

    printf("[READ %zd bytes as text]\n", nread);
    printf("%s\n", buf);
    printf("[READ %zd bytes as hex]\n", nread);
    hexdump(buf, (size_t)nread);

    // 写入数据（同一fd：如果你刚刚把偏移读到末尾，那么此处会“追加”；如果未读到末尾则从当前偏移写）
    printf("\n== Write \"%s\" ==\n", wbuf);
    if (write_all(fd, (const unsigned char*)wbuf, strlen(wbuf)) < 0) {
        perror("write");
        close(fd);
        return 1;
    }
    printf("Write OK (%zu bytes)\n", strlen(wbuf));

    close(fd);

    // 重新打开，从头再读一次，验证最终内容
    printf("\n== Reopen & read from beginning ==\n");
    fd = open(devpath, O_RDWR);
    if (fd < 0) {
        perror("open");
        return 1;
    }
    memset(buf, 0, sizeof(buf));
    nread = read_all_until_eof(fd, buf, sizeof(buf)-1);
    if (nread < 0) {
        perror("read");
        close(fd);
        return 1;
    }
    buf[nread] = '\0';

    printf("[READ %zd bytes as text]\n", nread);
    printf("%s\n", buf);
    printf("[READ %zd bytes as hex]\n", nread);
    hexdump(buf, (size_t)nread);

    close(fd);
    return 0;
}
测试代码
sudo ./app  //测试 /dev/mychardev0
sudo ./app /dev/mychardev1 //测试第二个
 
[  290.742004] Allocated: major=239 minors=[0..1]
[  290.744690] mychardev: init OK with 2 minors
[  302.178974] mychardev: open (major=239, minor=0)
[  302.179071] mychardev: read 46 bytes, new pos=46
[  302.183983] mychardev: wrote 12 bytes, new pos=58, data(hex, first 12B): 68656c6c6f206b65726e656c
[  302.184052] mychardev: release
[  302.184711] mychardev: open (major=239, minor=0)
[  302.184742] mychardev: read 58 bytes, new pos=58
[  302.185102] mychardev: release
[  322.556090] mychardev: open (major=239, minor=1)
[  322.556186] mychardev: read 46 bytes, new pos=46
[  322.560685] mychardev: wrote 12 bytes, new pos=58, data(hex, first 12B): 68656c6c6f206b65726e656c
[  322.560757] mychardev: release
[  322.560866] mychardev: open (major=239, minor=1)
[  322.560889] mychardev: read 58 bytes, new pos=58
[  322.561773] mychardev: release== Open & read from: /dev/mychardev0 ==
[READ 46 bytes as text]
Hello from kernel space! this is my_cdev_read

[READ 46 bytes as hex]
48 65 6C 6C 6F 20 66 72 6F 6D 20 6B 65 72 6E 65
6C 20 73 70 61 63 65 21 20 74 68 69 73 20 69 73
20 6D 79 5F 63 64 65 76 5F 72 65 61 64 0A

== Write "hello kernel" ==
Write OK (12 bytes)

== Reopen & read from beginning ==
[READ 58 bytes as text]
Hello from kernel space! this is my_cdev_read
hello kernel
[READ 58 bytes as hex]
48 65 6C 6C 6F 20 66 72 6F 6D 20 6B 65 72 6E 65
6C 20 73 70 61 63 65 21 20 74 68 69 73 20 69 73
20 6D 79 5F 63 64 65 76 5F 72 65 61 64 0A 68 65
6C 6C 6F 20 6B 65 72 6E 65 6C
[root@luckfox ]# ./app /dev/mychardev1
== Open & read from: /dev/mychardev1 ==
[READ 46 bytes as text]
Hello from kernel space! this is my_cdev_read

[READ 46 bytes as hex]
48 65 6C 6C 6F 20 66 72 6F 6D 20 6B 65 72 6E 65
6C 20 73 70 61 63 65 21 20 74 68 69 73 20 69 73
20 6D 79 5F 63 64 65 76 5F 72 65 61 64 0A

== Write "hello kernel" ==
Write OK (12 bytes)

== Reopen & read from beginning ==
[READ 58 bytes as text]
Hello from kernel space! this is my_cdev_read
hello kernel
[READ 58 bytes as hex]
48 65 6C 6C 6F 20 66 72 6F 6D 20 6B 65 72 6E 65
6C 20 73 70 61 63 65 21 20 74 68 69 73 20 69 73
20 6D 79 5F 63 64 65 76 5F 72 65 61 64 0A 68 65
6C 6C 6F 20 6B 65 72 6E 65 6C
以上为实验结果
# 杂项设备驱动
 linux中，把无法分类的五花八门的设备定义为杂项设备。相对于字符设备来说，杂项设备的主设备号固定为10.而字符设备不管是动态分配还是静态分配都会消耗一个主设备号。所以
 杂项设备主要是通过次设备来区分设备。
 杂项设备一般会自己调用class_create和device_Create()来自动创建设备节点。所以可以把杂项设备看成字符设备的一种。
 struct miscdevice  {
	int minor;
	const char *name; //告诉他自动帮我们创建的设备节点叫什么名字
	const struct file_operations *fops;//系统调用与驱动中 open read write 的桥梁
	struct list_head list;
	struct device *parent;
	struct device *this_device;
	const struct attribute_group **groups;
	const char *nodename;
	umode_t mode;
};
/home/guoyuge/luckfox-pico/sysdrv/source/kernel/include/linux/miscdevice.h
其中次设备号 minor一般使用宏MISC_DYNAMIC_MINOR 表示自动分配次设备号。杂项设备主要依赖次设备号来管理不同的杂项设备。

int misc_register(struct miscdevice *misc);
int misc_deregister(struct miscdevice *misc);
成功返回0 失败返回负数

#include <linux/module.h>
#include <linux/init.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/mutex.h>
#include <linux/string.h>
#include <linux/minmax.h>
#include <linux/miscdevice.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Luckfox");
MODULE_VERSION("V1.2");
MODULE_DESCRIPTION("A simple and robust misc device driver");

#define KBUF_SIZE 100


/* ------------ file operations ------------ */

static int my_cdev_open(struct inode *inode, struct file *file)
{
	    
	pr_info("mymiscdev: open\n");
	return 0;
}

static ssize_t my_cdev_read(struct file *file, char __user *buf, size_t size, loff_t *off)
{
	pr_info("mymiscdev: read\n");
}

static ssize_t my_cdev_write(struct file *file, const char __user *buf, size_t size, loff_t *off)
{
    pr_info("mymiscdev: write\n");
}

static int my_cdev_release(struct inode *inode, struct file *file)
{
	pr_info("mymiscdev: release\n");
	return 0;
}

static const struct file_operations fops = {
	.owner   = THIS_MODULE,
	.open    = my_cdev_open,
	.read    = my_cdev_read,
	.write   = my_cdev_write,
	.release = my_cdev_release,
	.llseek  = no_llseek,   /* 禁用 lseek，避免随意改偏移 */
};

/* ------------ miscdevice ------------ */

static struct miscdevice mymiscdev = {
	.minor = MISC_DYNAMIC_MINOR,  /* 动态分配次设备号 */
	.name  = "mymiscdev",         /* 会生成 /dev/mymiscdev */
	.fops  = &fops,
	.mode  = 0666,                /* 节点权限（按需调整） */
};

/* ------------ init / exit ------------ */

static int __init modulecdev_init(void)
{

	ret = misc_register(&mymiscdev);
	if (ret) {
		pr_err("mymiscdev: misc_register failed: %d\n", ret);
		return ret;
	}

	/* 成功后，内核会把实际的 minor 写到 mymiscdev.minor */
	pr_info("mymiscdev: init OK, minor=%d (node: /dev/%s)\n",
		mymiscdev.minor, mymiscdev.name);
	return 0;
}

static void __exit modulecdev_exit(void)
{
	misc_deregister(&mymiscdev);
	pr_info("mymiscdev: exit OK\n");
}

module_init(modulecdev_init);
module_exit(modulecdev_exit); 
最简单的示例代码 需要什么自己加

# linux驱动错误处理
    实际上还是goto语句的使用，也就是错误处理。
    先进后出的原则
    函数加载顺序 函数 1 2 3
    goto标签    err  3 2 1 
    先写最下面的 往上补

    如果返回值是指针的话 就可以用下面的例子
        if (IS_ERR(d->dev)) {
            ret = PTR_ERR(d->dev);
            pr_err("device_create minor=%d failed: %d\n",
                   MINOR(devt), ret);
            d->dev = NULL;
            goto err_loop;
        }
# 点亮一个led
    led GPIO3_C6_d
    步骤1:找到led灯是哪个GPIO控制。led GPIO3_C6_d
    步骤2:配置GPIO口。(复用关系,方向,数据)
    IOmux 选择GPIO3_C6：0xFF558054 其中的[8，10]值为0  io -4 0xFF558054 0x07000000  
    I/O modle output  :   0xFF55000C    [6,6]      1   io -4 0xFF55000C 0x00400040
    output high 0xFF550004  [6,6]  1  io -4 0xFF550004 0x00400040 亮灯
    output low 0xFF550004  [6,6]  0 io -4 0xFF550004 0x00400000  灭灯
    Input Ctrl  disable 0xFF5581A8 [6,6] 0   io -4 0xFF5581A8 0x00400000
    Schmitt disable 0xFF5582A8 [6,6] 0 io -4 0xFF5582A8 0x00400000
    Drive Strength 4mA 0xFF55812C [0,5] 3 io -4 0xFF55812C 0x003F0003

    GPIO文件描述Rockchip_RV1106_User_Manual_GPIO.pdf 每一个gpio口都在这个文件里面
    // SPDX-License-Identifier: GPL-2.0
// Minimal LED driver for GPIO3_C6 using write-mask registers
// Addresses & bitfields per user's register map (Luckfox/Rockchip-like)

#include <linux/module.h>
#include <linux/init.h>
#include <linux/io.h>
#include <linux/err.h>
#include <linux/leds.h>
#include <linux/mutex.h>
#include <linux/bitops.h>

#define DRV_NAME "rk-gpio3_c6-led"

// -------------------- 寄存器物理地址（按你的表） --------------------
#define IOMUX_ADDR          0xFF558054  // [10:8] 选择 0 为 GPIO
#define GPIO_SWPORT_DR      0xFF550004  // [6] 数据寄存器
#define GPIO_SWPORT_DDR     0xFF55000C  // [6] 方向寄存器
#define INPUT_CTL_ADDR      0xFF5581A8  // [6] 输入控制 (0=disable)
#define SCHMITT_ADDR        0xFF5582A8  // [6] 施密特 (0=disable)
#define DRIVE_STRENGTH_ADDR 0xFF55812C  // [5:0] 驱动能力，3=4mA

#define PIN_BIT             6           // GPIO3_C6 -> bit6
#define MAP_SIZE            0x1000      // 映射 4KB 页

// -------------------- 可调模块参数 --------------------
// 若你的板子是低电平点亮，将 active_low=1
static bool active_low;
module_param(active_low, bool, 0644);
MODULE_PARM_DESC(active_low, "Set to 1 if LED is active-low.");

static unsigned int drive_ma = 4; // 0/2/4/6/8/10/12 之一（按表映射到 0..63）
module_param(drive_ma, uint, 0644);
MODULE_PARM_DESC(drive_ma, "Drive strength in mA (mapped to [5:0]). Typical 4mA.");

// -------------------- MMIO 基址 --------------------
static void __iomem *iomux_base;
static void __iomem *gpio_base_dr;
static void __iomem *gpio_base_ddr;
static void __iomem *input_ctl_base;
static void __iomem *schmitt_base;
static void __iomem *drive_base;

static struct led_classdev rk_led_cdev;
static DEFINE_MUTEX(rk_led_lock);

// -------------------- 写掩码工具函数 --------------------
// 写掩码 32bit：高16位为掩码，低16位为数据（只针对低16位 bit 有效）
static inline void writemask32(void __iomem *addr, u32 mask_low16, u32 val_low16)
{
	writel((mask_low16 << 16) | (val_low16 & mask_low16), addr);
}

// 单 bit 写（bit 必须在 0..15 内；本项目用 bit6）
static inline void writemask32_bit(void __iomem *addr, u32 bit, bool set)
{
	u32 m = 1U << (bit & 15);
	writel((m << 16) | (set ? m : 0), addr);
}

// -------------------- LED 回调 --------------------
static void rk_led_set_brightness(struct led_classdev *cdev,
				  enum led_brightness brightness)
{
	void __iomem *dr = gpio_base_dr + (GPIO_SWPORT_DR & 0xFFF);
	bool on = (brightness != LED_OFF);

	if (active_low)
		on = !on;

	mutex_lock(&rk_led_lock);
	writemask32_bit(dr, PIN_BIT, on);
	mutex_unlock(&rk_led_lock);
}

// -------------------- 模块加载/卸载 --------------------
static int __init rk_led_init(void)
{
	int ret = 0;
	u32 drive_sel = 3; // 缺省 4mA -> 3

	// 计算驱动能力编码：按你的表 [5:0] 直接写 0..63
	switch (drive_ma) {
	case 0:  drive_sel = 0;  break;
	case 2:  drive_sel = 1;  break;
	case 4:  drive_sel = 3;  break;
	case 6:  drive_sel = 7;  break;
	case 8:  drive_sel = 15; break;
	case 10: drive_sel = 31; break;
	case 12: drive_sel = 63; break;
	default: drive_sel = 3;  break; // 兜底 4mA
	}

	// ioremap 到各自所在页
	iomux_base     = ioremap(IOMUX_ADDR          & ~0xFFF, MAP_SIZE);
	gpio_base_dr   = ioremap(GPIO_SWPORT_DR      & ~0xFFF, MAP_SIZE);
	gpio_base_ddr  = ioremap(GPIO_SWPORT_DDR     & ~0xFFF, MAP_SIZE);
	input_ctl_base = ioremap(INPUT_CTL_ADDR      & ~0xFFF, MAP_SIZE);
	schmitt_base   = ioremap(SCHMITT_ADDR        & ~0xFFF, MAP_SIZE);
	drive_base     = ioremap(DRIVE_STRENGTH_ADDR & ~0xFFF, MAP_SIZE);

	if (!iomux_base || !gpio_base_dr || !gpio_base_ddr ||
	    !input_ctl_base || !schmitt_base || !drive_base) {
		pr_err(DRV_NAME ": ioremap failed\n");
		ret = -ENOMEM;
		goto err_unmap;
	}

	// 1) 复用为 GPIO：IOMUX [10:8] = 0  -> 掩码 0x0700, 值 0x0000
	writemask32(iomux_base + (IOMUX_ADDR & 0xFFF), 0x0700, 0x0000);

	// 2) InputCtrl/Schmitt 禁用：bit6 = 0
	writemask32_bit(input_ctl_base + (INPUT_CTL_ADDR & 0xFFF), PIN_BIT, false);
	writemask32_bit(schmitt_base   + (SCHMITT_ADDR   & 0xFFF), PIN_BIT, false);

	// 3) 驱动能力：DRIVE_STRENGTH [5:0] = drive_sel
	writemask32(drive_base + (DRIVE_STRENGTH_ADDR & 0xFFF), 0x003F, drive_sel);

	// 4) 方向 -> 输出
	writemask32_bit(gpio_base_ddr + (GPIO_SWPORT_DDR & 0xFFF), PIN_BIT, true);

	// 5) 默认灭灯（根据 active_low）
	{
		bool on = false;
		if (active_low) on = true; // active_low 时，灭灯=输出高；上电先输出"灭"
		writemask32_bit(gpio_base_dr + (GPIO_SWPORT_DR & 0xFFF), PIN_BIT, on);
	}

	// 6) 注册 LED class
	rk_led_cdev.name = "rk-gpio3_c6";       // /sys/class/leds/rk-gpio3_c6
	rk_led_cdev.max_brightness = 255;
	rk_led_cdev.brightness_set = rk_led_set_brightness;

	ret = led_classdev_register(NULL, &rk_led_cdev);
	if (ret) {
		pr_err(DRV_NAME ": led_classdev_register failed: %d\n", ret);
		goto err_unmap;
	}

	pr_info(DRV_NAME ": loaded (active_low=%d, drive=%umA)\n", active_low, drive_ma);
	return 0;

err_unmap:
	if (iomux_base)     iounmap(iomux_base);
	if (gpio_base_dr)   iounmap(gpio_base_dr);
	if (gpio_base_ddr)  iounmap(gpio_base_ddr);
	if (input_ctl_base) iounmap(input_ctl_base);
	if (schmitt_base)   iounmap(schmitt_base);
	if (drive_base)     iounmap(drive_base);
	return ret;
}

static void __exit rk_led_exit(void)
{
	led_classdev_unregister(&rk_led_cdev);
	if (iomux_base)     iounmap(iomux_base);
	if (gpio_base_dr)   iounmap(gpio_base_dr);
	if (gpio_base_ddr)  iounmap(gpio_base_ddr);
	if (input_ctl_base) iounmap(input_ctl_base);
	if (schmitt_base)   iounmap(schmitt_base);
	if (drive_base)     iounmap(drive_base);
	pr_info(DRV_NAME ": unloaded\n");
}

module_init(rk_led_init);
module_exit(rk_led_exit);

MODULE_DESCRIPTION("Minimal LED driver for GPIO3_C6 using writemask registers");
MODULE_AUTHOR("li leyi (plus-81) & ChatGPT");
MODULE_LICENSE("GPL");


# 首先我们打开 其中gpio口的pdf文件

    我们先查看IOmux选择 当我们启用GPIO3_C6的时候 当我们要对寄存器 0xFF558054 的[8，10]的值 置0 他进行的操作时io -4 0xFF558054 0x07000000
    MIPI_REFCLK_OUT1 时候 需要置3 进行的操作是io -4 0xFF558054 0x07000300
    
    我们可以判断出 我们寄存器使用的是 高16位掩码 低16位数据的形式 而且io -4  典型特征：
    故此推断，rv1106是使用Write mask

    static inline void writemask32(void __iomem *addr, u32 mask_low16, u32 val_low16)
{
    writel((mask_low16 << 16) | (val_low16 & mask_low16), addr);
}
十六进制：   0    7    0    0
二进制：   0000 0111 0000 0000
位号：     15..12 11..8  7..4  3..0   ← 每个十六进制位=4个二进制位
                ↑↑↑
                11 10 9 8  这四个位属于中间这个“7”的那一组
补充知识 位号是从0开始的
先讲规则：16+16 写掩码寄存器
这类寄存器规定：一次写 32 位，其中
高 16 位 [31:16] = 掩码（Mask）：“我要改哪些位”；
低 16 位 [15:0] = 数据（Value）：“把这些位改成什么值”。
mask_low16 << 16
把“要改哪些位”的掩码，放到高 16 位上（硬件规定的位置）。
val_low16 & mask_low16
把“要写的值”先与掩码 AND 一下：
目的：保证只有被掩码选中的那些位才会出现在低 16 位的数据里；
防呆：如果 val_low16 不小心带了别的位，也会被 & mask 清掉，避免误写。
(...) | (...)
把高 16 位的掩码和低 16 位的数据拼在一起，形成一次 32 位写入值。
writel(32位合成值, addr); 就写到寄存器了。


没问题，我们就把这个**单 bit 写**函数掰开讲清楚：

```c
// 单 bit 写（bit 必须在 0..15 内；本项目用 bit6）
static inline void writemask32_bit(void __iomem *addr, u32 bit, bool set)
{
    u32 m = 1U << (bit & 15);
    writel((m << 16) | (set ? m : 0), addr);
}
```
## 它的用途
针对**16+16 写掩码寄存器**，**只修改一个比特位**（bit0..bit15），要么置 1，要么清 0，而且不影响其它位。
## 每行在干嘛
1. `u32 m = 1U << (bit & 15);`
   * 生成目标位的**低 16 位掩码**。
   * `bit & 15` 的作用是把传入的 `bit` 限制在 0..15 范围（因为这类寄存器只对低 16 位支持写掩码）。
   * 举例：
     * 如果 `bit=6`，`m = 1<<6 = 0x0040`
     * 如果 `bit=10`，`m = 1<<10 = 0x0400`
2. `writel((m << 16) | (set ? m : 0), addr);`
   * **高 16 位**写入掩码：`m << 16` → “只改这一位”。
   * **低 16 位**写入数据：
     * `set ? m : 0`
     * `set=true` → 这一位写成 **1**
     * `set=false` → 这一位写成 **0**
   * 两者或起来，形成一次 32 位写（写掩码格式要求）：`[31:16]=掩码，[15:0]=数据`。
## 和你命令行的等价关系（关键！）
以 `bit6` 为例（`m=0x0040`）：
* **置 1**：`(m<<16)|(m)` = `0x00400040`
  等价命令：`io -4 <寄存器地址> 0x00400040`
* **清 0**：`(m<<16)|0` = `0x00400000`
  等价命令：`io -4 <寄存器地址> 0x00400000`
以 `bit10` 为例（`m=0x0400`）：
* 置 1 → `0x04000400`
* 清 0 → `0x04000000`
## 什么时候用它
* 改单一开关位：如 **GPIO 方向位 DDR 的 bit6**、**数据位 DR 的 bit6**、某个 enable/disable 位。
* 你的实际用法：
  * DDR（方向）设输出：`writemask32_bit(ddr, 6, true);`  ⇔ `io -4 0xFF55000C 0x00400040`
  * DR（数据）拉低：`writemask32_bit(dr, 6, false);` ⇔ `io -4 0xFF550004 0x00400000`
## 小心些坑
* **只能改低 16 位**（bit0..15）。`bit&15` 就是强制这一点；如果目标位是 16..31，就不能用这个函数，要按手册用别的写法。
* 仅适用于**“16+16 写掩码”风格**的寄存器；对普通寄存器需要 RMW 或 SET/CLR/W1C 等别的写法。
* 若你的 LED 是**低电平点亮**，则“置 1/清 0”的含义对亮灭要倒过来（这是电路极性问题，不是函数问题）。
## 一句话总结
* `writemask32_bit(addr, bit, true)`：**把 bit 置 1**，等价写值 `(1<<bit)` 同时作为**高 16 位掩码**和**低 16 位数据**。
* `writemask32_bit(addr, bit, false)`：**把 bit 清 0**，等价写值 `(1<<bit)<<16`（低 16 位数据为 0）。
* 这正好和你一直在用的 `io -4` 写值一一对应。
input 0xFF55000C [6,6] 0 io -4 0xFF55000C 0x00400000
output 0xFF55000C [6,6] 1 io -4 0xFF55000C 0x00400040
low 0xFF550004 [6,6] 0 io -4 0xFF550004 0x00400000
high 0xFF550004 [6,6] 1 io -4 0xFF550004 0x00400040
disable 0xFF5581A8 [6,6] 0 io -4 0xFF5581A8 0x00400000
enable 0xFF5581A8 [6,6] 1 io -4 0xFF5581A8 0x00400040
disable 0xFF5582A8 [6,6] 0 io -4 0xFF5582A8 0x00400000
enable 0xFF5582A8 [6,6] 1 io -4 0xFF5582A8 0x00400040
因为这些一直在对寄存器的第6位进行操作 所以单独写了一个只操作一个bit位的函数 


// SPDX-License-Identifier: GPL-2.0
// Char-device LED driver for GPIO3_C6 with writemask registers
// (多指针多次 ioremap 版本，便于直观查看)

#include <linux/module.h>
#include <linux/init.h>
#include <linux/moduleparam.h>
#include <linux/fs.h>
#include <linux/kdev_t.h>
#include <linux/types.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/uaccess.h>
#include <linux/mutex.h>
#include <linux/string.h>
#include <linux/ctype.h>
#include <linux/io.h>

#define DRV_NAME "mychardev_led"

// -------------------- 物理地址（按你的表） --------------------
#define IOMUX_ADDR          0xFF558054  // [10:8] 选择 0 为 GPIO
#define GPIO_SWPORT_DR      0xFF550004  // [6] 数据寄存器(0=low,1=high)
#define GPIO_SWPORT_DDR     0xFF55000C  // [6] 方向寄存器(0=input,1=output)
#define INPUT_CTL_ADDR      0xFF5581A8  // [6] 输入控制 (0=disable)
#define SCHMITT_ADDR        0xFF5582A8  // [6] 施密特 (0=disable)
#define DRIVE_STRENGTH_ADDR 0xFF55812C  // [5:0] 驱动能力，3=4mA

#define PIN_BIT             6           // GPIO3_C6 -> bit6
#define MAP_SIZE            0x1000      // 每页映射 4KB

// -------------------- 模块参数 --------------------
static bool active_low;                 // 低电平点亮？
module_param(active_low, bool, 0644);
MODULE_PARM_DESC(active_low, "Set to 1 if LED is active-low.");

static unsigned int drive_ma = 4;       // 0/2/4/6/8/10/12 -> 映射到 [5:0]
module_param(drive_ma, uint, 0644);
MODULE_PARM_DESC(drive_ma, "Drive strength mA (0,2,4,6,8,10,12). 4mA default.");

#define KBUF_SIZE 128

// -------------------- 设备结构 --------------------
struct mydev_t {
    dev_t dev_num;
    struct cdev cdev;
    struct class *cls;
    struct device *dev;

    char   kbuf[KBUF_SIZE];
    size_t datalen;
    struct mutex lock;

    // 保持你的“多指针多次映射”风格（看起来一一对应）
    void __iomem *iomux_base;      // 页基址：IOMUX 所在页
    void __iomem *gpio_base_dr;    // 页基址：DR 所在页
    void __iomem *gpio_base_ddr;   // 页基址：DDR 所在页（与 DR 同页，这里按你的风格单列）
    void __iomem *input_ctl_base;  // 页基址：InputCtrl 所在页
    void __iomem *schmitt_base;    // 页基址：Schmitt 所在页
    void __iomem *drive_base;      // 页基址：DriveStrength 所在页
};

static struct mydev_t mydev;

// -------------------- 写掩码工具 --------------------
// 写掩码 32bit：高16位=掩码，低16位=数据（仅低16位字段生效）
static inline void writemask32(void __iomem *addr, u32 mask_low16, u32 val_low16)
{
    writel((mask_low16 << 16) | (val_low16 & mask_low16), addr);
}

// 单 bit 写（bit 必须 0..15）
static inline void writemask32_bit(void __iomem *addr, u32 bit, bool set)
{
    u32 m = 1U << (bit & 15);
    writel((m << 16) | (set ? m : 0), addr);
}

// 页内偏移助手
static inline void __iomem *reg_ptr(void __iomem *base, phys_addr_t phys)
{
    return base + (phys & 0xFFF);
}

// 读当前 DR bit（原始，不考虑 active_low）
static inline bool read_dr_bit(struct mydev_t *d)
{
    u32 v = readl(reg_ptr(d->gpio_base_dr, GPIO_SWPORT_DR));
    return !!(v & (1U << PIN_BIT));
}

/* ------------ file operations ------------ */

static int my_cdev_open(struct inode *inode, struct file *file)
{
    file->private_data = &mydev;
    pr_info(DRV_NAME ": open\n");
    return 0;
}

static ssize_t my_cdev_read(struct file *file, char __user *buf, size_t size, loff_t *off)
{
    struct mydev_t *d = file->private_data;
    char out[8];
    size_t len;
    bool is_on_raw, is_on;

    mutex_lock(&d->lock);
    is_on_raw = read_dr_bit(d);
    is_on = active_low ? !is_on_raw : is_on;

    // 修正：is_on 应该从 is_on_raw 计算
    is_on = active_low ? !is_on_raw : is_on_raw;

    len = scnprintf(out, sizeof(out), "%d\n", is_on ? 1 : 0);

    if (*off >= len) {
        mutex_unlock(&d->lock);
        return 0; // EOF
    }
    if (size > len - *off)
        size = len - *off;

    if (copy_to_user(buf, out + *off, size)) {
        mutex_unlock(&d->lock);
        return -EFAULT;
    }
    *off += size;
    mutex_unlock(&d->lock);
    return size;
}

// 把用户输入转成 on/off
static bool parse_on_off(const char *s, size_t n, bool *p_on)
{
    // 去空白
    size_t i = 0, j = n;
    while (i < n && isspace(s[i])) i++;
    while (j > i && isspace(s[j-1])) j--;
    if (j <= i) return false;

    if (j - i == 1 && (s[i] == '1' || s[i] == '0')) {
        *p_on = (s[i] == '1');
        return true;
    }
    if ((j - i) == 2 &&
        (tolower(s[i])=='o') && (tolower(s[i+1])=='n')) {
        *p_on = true; return true;
    }
    if ((j - i) == 3 &&
        (tolower(s[i])=='o') && (tolower(s[i+1])=='f') && (tolower(s[i+2])=='f')) {
        *p_on = false; return true;
    }
    return false;
}

static ssize_t my_cdev_write(struct file *file, const char __user *buf, size_t size, loff_t *off)
{
    struct mydev_t *d = file->private_data;
    ssize_t ret = 0;
    size_t n = min_t(size_t, size, KBUF_SIZE - 1);
    bool want_on, out_level;

    if (n == 0) return -EINVAL;

    mutex_lock(&d->lock);

    if (copy_from_user(d->kbuf, buf, n)) {
        ret = -EFAULT;
        goto out;
    }
    d->kbuf[n] = '\0';
    d->datalen = n;

    if (!parse_on_off(d->kbuf, n, &want_on)) {
        pr_info(DRV_NAME ": write expects '1/0' or 'on/off'\n");
        ret = -EINVAL;
        goto out;
    }

    out_level = active_low ? !want_on : want_on;

    // 写 DR bit6
    writemask32_bit(reg_ptr(d->gpio_base_dr, GPIO_SWPORT_DR), PIN_BIT, out_level);

    ret = size;

out:
    mutex_unlock(&d->lock);
    return ret;
}

static int my_cdev_release(struct inode *inode, struct file *file)
{
    pr_info(DRV_NAME ": release\n");
    return 0;
}

static const struct file_operations fops = {
    .owner   = THIS_MODULE,
    .open    = my_cdev_open,
    .read    = my_cdev_read,
    .write   = my_cdev_write,
    .release = my_cdev_release,
    .llseek  = no_llseek,
};

/* ------------ init / exit ------------ */

static int __init modulecdev_init(void)
{
    int ret;
    u32 drive_sel;

    // 1) 分配设备号
    ret = alloc_chrdev_region(&mydev.dev_num, 0, 1, DRV_NAME);
    if (ret) {
        pr_err(DRV_NAME ": alloc_chrdev_region failed: %d\n", ret);
        return ret;
    }
    pr_info(DRV_NAME ": major=%d minor=%d\n", MAJOR(mydev.dev_num), MINOR(mydev.dev_num));

    mutex_init(&mydev.lock);
    mydev.datalen = 0;

    // 2) 注册 cdev
    cdev_init(&mydev.cdev, &fops);
    ret = cdev_add(&mydev.cdev, mydev.dev_num, 1);
    if (ret) {
        pr_err(DRV_NAME ": cdev_add failed: %d\n", ret);
        goto err_unregister;
    }

    // 3) 创建 class / device
    mydev.cls = class_create(THIS_MODULE, "mychardev_class");
    if (IS_ERR(mydev.cls)) {
        ret = PTR_ERR(mydev.cls);
        pr_err(DRV_NAME ": class_create failed: %d\n", ret);
        mydev.cls = NULL;
        goto err_cdev_del;
    }

    mydev.dev = device_create(mydev.cls, NULL, mydev.dev_num, NULL, "mychardev%d", MINOR(mydev.dev_num));
    if (IS_ERR(mydev.dev)) {
        ret = PTR_ERR(mydev.dev);
        pr_err(DRV_NAME ": device_create failed: %d\n", ret);
        mydev.dev = NULL;
        goto err_class_destroy;
    }

    // 4) 多指针多次 ioremap（每页各映射 4KB）
    mydev.iomux_base     = ioremap(IOMUX_ADDR          & ~0xFFF, MAP_SIZE);
    mydev.gpio_base_dr   = ioremap(GPIO_SWPORT_DR      & ~0xFFF, MAP_SIZE);
    mydev.gpio_base_ddr  = ioremap(GPIO_SWPORT_DDR     & ~0xFFF, MAP_SIZE);
    mydev.input_ctl_base = ioremap(INPUT_CTL_ADDR      & ~0xFFF, MAP_SIZE);
    mydev.schmitt_base   = ioremap(SCHMITT_ADDR        & ~0xFFF, MAP_SIZE);
    mydev.drive_base     = ioremap(DRIVE_STRENGTH_ADDR & ~0xFFF, MAP_SIZE);

    if (!mydev.iomux_base || !mydev.gpio_base_dr || !mydev.gpio_base_ddr ||
        !mydev.input_ctl_base || !mydev.schmitt_base || !mydev.drive_base) {
        pr_err(DRV_NAME ": ioremap failed\n");
        ret = -ENOMEM;
        goto err_unmap;
    }

    // 5) 一次性初始化（按你的表）
    // IOMUX [10:8] = 0 -> 选 GPIO
    writemask32(reg_ptr(mydev.iomux_base, IOMUX_ADDR), 0x0700, 0x0000);

    // InputCtrl/Schmitt 禁用（输出场景）
    writemask32_bit(reg_ptr(mydev.input_ctl_base, INPUT_CTL_ADDR), PIN_BIT, false);
    writemask32_bit(reg_ptr(mydev.schmitt_base,   SCHMITT_ADDR),   PIN_BIT, false);

    // 驱动能力 [5:0]：根据 drive_ma 映射
    switch (drive_ma) {
    case 0:  drive_sel = 0;  break;
    case 2:  drive_sel = 1;  break;
    case 4:  drive_sel = 3;  break;
    case 6:  drive_sel = 7;  break;
    case 8:  drive_sel = 15; break;
    case 10: drive_sel = 31; break;
    case 12: drive_sel = 63; break;
    default: drive_sel = 3;  break; // 兜底 4mA
    }
    writemask32(reg_ptr(mydev.drive_base, DRIVE_STRENGTH_ADDR), 0x003F, drive_sel);

    // 方向->输出
    writemask32_bit(reg_ptr(mydev.gpio_base_ddr, GPIO_SWPORT_DDR), PIN_BIT, true);

    // 默认灭灯：根据 active_low 选择输出电平
    writemask32_bit(reg_ptr(mydev.gpio_base_dr, GPIO_SWPORT_DR), PIN_BIT, active_low ? true : false);

    pr_info(DRV_NAME ": init OK (active_low=%d, drive=%umA)\n", active_low, drive_ma);
    pr_info(DRV_NAME ": device node /dev/%s%d\n", "mychardev", MINOR(mydev.dev_num));
    return 0;

err_unmap:
    if (mydev.iomux_base)     { iounmap(mydev.iomux_base);     mydev.iomux_base = NULL; }
    if (mydev.gpio_base_dr)   { iounmap(mydev.gpio_base_dr);   mydev.gpio_base_dr = NULL; }
    if (mydev.gpio_base_ddr)  { iounmap(mydev.gpio_base_ddr);  mydev.gpio_base_ddr = NULL; }
    if (mydev.input_ctl_base) { iounmap(mydev.input_ctl_base); mydev.input_ctl_base = NULL; }
    if (mydev.schmitt_base)   { iounmap(mydev.schmitt_base);   mydev.schmitt_base = NULL; }
    if (mydev.drive_base)     { iounmap(mydev.drive_base);     mydev.drive_base = NULL; }

    if (mydev.dev) { device_destroy(mydev.cls, mydev.dev_num); mydev.dev = NULL; }
err_class_destroy:
    if (mydev.cls) { class_destroy(mydev.cls); mydev.cls = NULL; }
err_cdev_del:
    cdev_del(&mydev.cdev);
err_unregister:
    unregister_chrdev_region(mydev.dev_num, 1);
    return ret;
}

static void __exit modulecdev_exit(void)
{
    // 退出前灭灯（可选）
    if (mydev.gpio_base_dr)
        writemask32_bit(reg_ptr(mydev.gpio_base_dr, GPIO_SWPORT_DR), PIN_BIT, active_low ? true : false);

    if (mydev.iomux_base)     { iounmap(mydev.iomux_base);     mydev.iomux_base = NULL; }
    if (mydev.gpio_base_dr)   { iounmap(mydev.gpio_base_dr);   mydev.gpio_base_dr = NULL; }
    if (mydev.gpio_base_ddr)  { iounmap(mydev.gpio_base_ddr);  mydev.gpio_base_ddr = NULL; }
    if (mydev.input_ctl_base) { iounmap(mydev.input_ctl_base); mydev.input_ctl_base = NULL; }
    if (mydev.schmitt_base)   { iounmap(mydev.schmitt_base);   mydev.schmitt_base = NULL; }
    if (mydev.drive_base)     { iounmap(mydev.drive_base);     mydev.drive_base = NULL; }

    if (mydev.dev) { device_destroy(mydev.cls, mydev.dev_num); mydev.dev = NULL; }
    if (mydev.cls) { class_destroy(mydev.cls); mydev.cls = NULL; }

    cdev_del(&mydev.cdev);
    unregister_chrdev_region(mydev.dev_num, 1);
    pr_info(DRV_NAME ": exit\n");
}

module_init(modulecdev_init);
module_exit(modulecdev_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Luckfox");
MODULE_VERSION("V1.2");
MODULE_DESCRIPTION("Char device for GPIO3_C6 LED (multi-ioremap style)");
这个代码 和之前的字符驱动的流程差不多一样 只加了一个往寄存器写值的两个函数 和在init里面做了一些基本的初始化 具体控制亮灭还是在write函数中 然后 还是具体映射需要学习 最好使用我代码上的好几个映射到一个页面上 然后用页偏移来
来寻找需要驱动的寄存器。


# 一个主设备多个次设备
// 字符设备驱动框架 - 每个 minor 一个 cdev（含并发与越界处理）
#include <linux/module.h>
#include <linux/init.h>
#include <linux/moduleparam.h>
#include <linux/fs.h>
#include <linux/kdev_t.h>
#include <linux/types.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/uaccess.h>
#include <linux/mutex.h>
#include <linux/string.h>
#include <linux/slab.h>      // kcalloc, kfree
#include <linux/minmax.h>    // min_t

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Luckfox");
MODULE_VERSION("V1.3");
MODULE_DESCRIPTION("Char device driver: one cdev per minor");

#define KBUF_SIZE 100

/* 模块参数：起始次设备号、次设备数量（至少 1 个） */
static int minor = 0;
module_param(minor, int, 0644);
MODULE_PARM_DESC(minor, "First minor number of the device range");

static int num_minors = 2;
module_param(num_minors, int, 0644);
MODULE_PARM_DESC(num_minors, "Number of minors to create (>=1)");

/* 每个次设备自己的状态 */
struct perdev_t {
    struct cdev cdev;          /* 每个次设备一个 cdev（便于 container_of） */
    dev_t       devt;          /* 自己的设备号（销毁节点方便） */
    struct device *dev;        /* /dev 节点句柄 */

    char   kbuf[KBUF_SIZE];    //这个就是内核空间的缓冲区
    size_t datalen;
    struct mutex lock;
};
//perdev_t 结构体表示每个次设备的状态信息，包含一个字符设备对象（cdev）、
// 设备号（devt）、设备节点句柄（dev）、内核缓冲区（kbuf）、有效数据长度（datalen）和一个互斥锁（lock）用于并发保护。
/* 驱动整体上下文：class + 设备号范围 + 实例数组 */
static struct {
    dev_t first_dev;           /* 首个设备号（含主设备号 + 起始次设备号） 基准起点*/
    struct class *cls;         /* 公用 class */
    struct perdev_t *devs;     /* 动态分配 num_minors 个实例 */
} g;
//g里面放的是整个驱动的属性，比如说class，设备号范围，实例数组等等
/* ------------ file operations ------------ */

static int my_cdev_open(struct inode *inode, struct file *file)
{
    /* 关键点：通过 i_cdev 反推回 perdev_t */
    struct perdev_t *d = container_of(inode->i_cdev, struct perdev_t, cdev);
    file->private_data = d;
    pr_info("mychardev: open (major=%u, minor=%u)\n",
            imajor(inode), iminor(inode));
    return 0;
}

static ssize_t my_cdev_read(struct file *file, char __user *buf, size_t size, loff_t *off)
{
    struct perdev_t *d = file->private_data;
    ssize_t ret = 0;

    mutex_lock(&d->lock);

    if (*off >= d->datalen) {               /* EOF */
        ret = 0;
        goto out;
    }

    if (size > d->datalen - *off)           /* 限幅：最多读剩余 */
        size = d->datalen - *off;

    if (copy_to_user(buf, d->kbuf + *off, size)) {
        ret = -EFAULT;
        goto out;
    }

    *off += size;
    ret = size;

    pr_info("mychardev: read %zd bytes, new pos=%llu\n",
            ret, (unsigned long long)*off);
out:
    mutex_unlock(&d->lock);
    return ret;
}

static ssize_t my_cdev_write(struct file *file, const char __user *buf, size_t size, loff_t *off)
{
    struct perdev_t *d = file->private_data;
    size_t space, n;
    ssize_t ret = 0;

    if (!size)
        return 0;

    mutex_lock(&d->lock);

    if (*off > KBUF_SIZE) {                  /* 越界写入位置 */
        ret = -EINVAL;
        goto out;
    }

    space = KBUF_SIZE - *off;                /* 剩余空间 */
    if (!space) {
        ret = -ENOSPC;
        goto out;
    }

    n = (size > space) ? space : size;       /* 实际可写 */

    if (copy_from_user(d->kbuf + *off, buf, n)) {
        ret = -EFAULT;
        goto out;
    }

    *off += n;
    if (*off > d->datalen)
        d->datalen = *off;

    ret = n;

    pr_info("mychardev: wrote %zd bytes, new pos=%llu, data(hex, first %zuB): %*phN\n",
            ret, (unsigned long long)*off,
            (size_t)min_t(size_t, n, 32),
            (int)min_t(size_t, n, 32), d->kbuf + (*off - n));
out:
    mutex_unlock(&d->lock);
    return ret;
}

static int my_cdev_release(struct inode *inode, struct file *file)
{
    pr_info("mychardev: release\n");
    return 0;
}

static const struct file_operations fops = {
    .owner   = THIS_MODULE,
    .open    = my_cdev_open,
    .read    = my_cdev_read,
    .write   = my_cdev_write,
    .release = my_cdev_release,
    .llseek  = no_llseek,      /* 禁用 lseek，避免随意改偏移 */
};

/* ------------ init / exit ------------ */

static int __init modulecdev_init(void)
{
    int ret;
    int i;

    if (num_minors < 1)
        num_minors = 1;

    /* 1) 申请一段设备号：num_minors 个 */
    ret = alloc_chrdev_region(&g.first_dev, minor, num_minors, "mychardev");
    if (ret) {
        pr_err("alloc_chrdev_region failed: %d\n", ret);
        return ret;
    }
    pr_info("Allocated: major=%d minors=[%d..%d]\n",
            MAJOR(g.first_dev), MINOR(g.first_dev),
            MINOR(g.first_dev) + num_minors - 1);

    /* 2) 分配 per-device 数组并初始化 */
    g.devs = kcalloc(num_minors, sizeof(*g.devs), GFP_KERNEL);//内存里确实已经“摆好了”两个零初始化的 perdev_t，
    // 你只需对关键成员做初始化即可投入使用，开辟了两个新的内存，但是内存里面并不是空的
    if (!g.devs) {
        ret = -ENOMEM;
        goto err_unreg;
    }

    g.cls = class_create(THIS_MODULE, "mychardev_class");
    if (IS_ERR(g.cls)) {
        ret = PTR_ERR(g.cls);
        pr_err("class_create failed: %d\n", ret);
        g.cls = NULL;
        goto err_free;
    }//也有人把 cdev_add() 放在 class_create() 之前做（顺序可以互换）
    // ，但**device_create() 一定在 class_create() 之后**，这点不变。你现在的顺序清晰且好维护。

    for (i = 0; i < num_minors; ++i) {
        struct perdev_t *d = &g.devs[i];
        //用指针d指向了perdev_t数组中的第i个元素，修改d就是在修改g.devs[i]
        dev_t devt = MKDEV(MAJOR(g.first_dev), MINOR(g.first_dev) + i);
        const char *hello = "Hello from kernel space! this is my_cdev_read\n";
        size_t hl;

        mutex_init(&d->lock);
        d->datalen = 0;

        /* 可选：每个次设备放一段初始内容（可按需区分） */
        hl = strnlen(hello, KBUF_SIZE);
        memcpy(d->kbuf, hello, hl);
        d->datalen = hl;

        cdev_init(&d->cdev, &fops);//这一步是把每个 perdev_t 结构体里的 cdev 成员初始化好，
        // 让它指向同一套 file_operations 函数集 fops，cdev可以是空的壳，等着后续填充
        //d->cdev.owner = THIS_MODULE;     /* 可选：多数新内核用 fops->owner 即可 */
        d->devt = devt;

        ret = cdev_add(&d->cdev, devt, 1);   /* ★ 每个 minor 单独 cdev_add */ //这一步是把每个 cdev 对象注册到内核中，
        // 让内核知道这个 cdev 对象对应哪个设备号，以及它的 file_operations 是什么
        if (ret) {
            pr_err("cdev_add minor=%d failed: %d\n", MINOR(devt), ret);
            goto err_loop;
        }

        d->dev = device_create(g.cls, NULL, devt, NULL,
                               "mychardev%d", MINOR(devt));
        if (IS_ERR(d->dev)) {
            ret = PTR_ERR(d->dev);
            pr_err("device_create minor=%d failed: %d\n",
                   MINOR(devt), ret);
            d->dev = NULL;
            goto err_loop;
        }
    }

    pr_info("mychardev: init OK with %d minors\n", num_minors);
    return 0;

err_loop:
    /* 回滚：销毁已创建的节点与 cdev */
    while (--i >= 0) {
        if (g.devs[i].dev) {
            device_destroy(g.cls, g.devs[i].devt);
            g.devs[i].dev = NULL;
        }
        cdev_del(&g.devs[i].cdev);
    }
    class_destroy(g.cls);
    g.cls = NULL;
err_free:
    kfree(g.devs);
    g.devs = NULL;
err_unreg:
    unregister_chrdev_region(g.first_dev, num_minors);
    return ret;
}

static void __exit modulecdev_exit(void)
{
    int i;

    for (i = 0; i < num_minors; ++i) {
        if (g.devs && g.devs[i].dev) {
            device_destroy(g.cls, g.devs[i].devt);
            g.devs[i].dev = NULL;
        }
        if (g.devs)
            cdev_del(&g.devs[i].cdev);
    }

    if (g.cls) {
        class_destroy(g.cls);
        g.cls = NULL;
    }

    if (g.devs) {
        kfree(g.devs);
        g.devs = NULL;
    }

    unregister_chrdev_region(g.first_dev, num_minors);
    pr_info("mychardev: all minors removed and region unregistered\n");
}

module_init(modulecdev_init);
module_exit(modulecdev_exit);


上面代码注释已经写了很清楚，具体不懂得看上面代码就可以。

 # 解释点
 struct perdev *pdevs;                 // 只是一个指针
pdevs = kcalloc(ndev, sizeof(*pdevs), GFP_KERNEL);
// 现在 pdevs 指向一段连续内存：| perdev0 | perdev1 | ... | perdev(ndev-1) |
pdevs[0]   // 等价于 *(pdevs + 0)
pdevs[3]   // 等价于 *(pdevs + 3)
&pdevs[i]  // 取第 i 个元素的地址（类型是 struct perdev *）
kfree(pdevs); // 释放整段“动态数组”


# 初始化内部状态一般放在分配设备号之后，确保设备号分配成功后再初始化
#  多指针多次 ioremap（每页各映射 4KB）  指针映射一般放在device_create之后，确保设备创建成功再映射

struct mydev_t {
    //这些变量是字符设备驱动框架通用的部分
    dev_t dev_num;
    struct cdev cdev;
    struct class *cls;
    struct device *dev;
    char   kbuf[KBUF_SIZE];
    //设备初始化时用到的变量 放在设备创建之前 申请设备号之后
    size_t datalen;
    struct mutex lock;

    // 保持你的“多指针多次映射”风格（看起来一一对应）   放在设备创建之后
    void __iomem *iomux_base;      // 页基址：IOMUX 所在页
    void __iomem *gpio_base_dr;    // 页基址：DR 所在页
    void __iomem *gpio_base_ddr;   // 页基址：DDR 所在页（与 DR 同页，这里按你的风格单列）
    void __iomem *input_ctl_base;  // 页基址：InputCtrl 所在页
    void __iomem *schmitt_base;    // 页基址：Schmitt 所在页
    void __iomem *drive_base;      // 页基址：DriveStrength 所在页
};
如果是一个的话 这样基本上 是全的

/* 每个次设备自己的状态 */
struct perdev_t {
    struct cdev cdev;          /* 每个次设备一个 cdev（便于 container_of） */
    dev_t       devt;          /* 自己的设备号（销毁节点方便） */
    struct device *dev;        /* /dev 节点句柄 */

    char   kbuf[KBUF_SIZE];    //这个就是内核空间的缓冲区
    size_t datalen;
    struct mutex lock;
};
//perdev_t 结构体表示每个次设备的状态信息，包含一个字符设备对象（cdev）、
// 设备号（devt）、设备节点句柄（dev）、内核缓冲区（kbuf）、有效数据长度（datalen）和一个互斥锁（lock）用于并发保护。
/* 驱动整体上下文：class + 设备号范围 + 实例数组 */
static struct {
    dev_t first_dev;           /* 首个设备号（含主设备号 + 起始次设备号） 基准起点*/
    struct class *cls;         /* 公用 class */
    struct perdev_t *devs;     /* 动态分配 num_minors 个实例 */
} g;
//g里面放的是整个驱动的属性，比如说class，设备号范围，实例数组等等
如果是多个设备 那么这个基本上就没有问题  这个后面有个关键的操作就是
    g.devs = kcalloc(num_minors, sizeof(*g.devs), GFP_KERNEL);//内存里确实已经“摆好了”两个零初始化的 perdev_t，
    // 你只需对关键成员做初始化即可投入使用，开辟了两个新的内存，但是内存里面并不是空的