1.heloword和makefile编写 见相关代码

2.驱动的安装和卸载
insmod 文件.ko
rmmod 文件.ko
dmesg | tail  看内核加载信息
内核加载信息有延迟
static void __exit hello_exit(void)
{
    printk(KERN_INFO "helloworldbb\n");
}
printk(KERN_ALERT "helloworldbb\n");
 KERN_ALERT 优先级最高，几乎一定会显示在 dmesg。

3.menuconfig

首先进入内核目录 # 内核源码路径
KDIR := /home/guoyuge/luckfox-pico/sysdrv/source/kernel
设置 先导入 export ARCH=arm
    (1)移动
    使用键盘的上,下,左,右按键可以移动光标。
    (2)搜索功能
    输入“/"即可弹出搜索界面，然后输入我们要搜索的内容即可。(3)配置驱动选项状态操作
    驱动状态:
    1.把驱动编译成模块，用M来表示
    2.把驱动编译到内核里面，用*来表示
    3.不编译。
    使用“空格”按键来配置这三种不同的状态。选项的状态有几,<>,()三种表示状态，其中门表示有俩种状态，只能设置成选中或者不选中，表示有三种状态，可以设置成选中，不选中，和编译成模块。()表示用来存放字符串或者16进制数

4。menuconfig 相关文件的关系 
makefile 菜的做法  kconfig 菜单  .config菜单点的菜品  config
    kconfig 是图形化配置界面的源文件  arch/xxx/config  xxx：export ARCH=arm 这就是为什么要指定arch
    kconfig位于linux源码的  arch/$(ARCH)/config 目录 是liux系统的默认配置文件
    .config在linux的顶层目录 编译内核会按照 .config中的配置来编译内核镜像    所以.config最重要
    若.config存在那么menuconfig 显示的就是当前.config文件 可以修改 保存会更新.config
    若.config不存在menuconfig显示的是 kconfig中的默认配置  
    使用命令make xxx_defconfig 会更具arch/$(ARCH)/config 生成.config   

    makefile告诉我们如何编译 定义了编译规则 

5.kconfig语法  来定义菜单
    config helloworld
        bool "hello world support"
        default y
        depends on A 
        help
            hello world
依赖关系
    Kconfig中的依赖关系可以用depends on和select。
    直接举例说明:
     depends on表示直接依赖关系:
     config A
     dependson B
     表示选项A依赖选项B，只有当B选项被选中时，A选项才可以被选中。
     select表示反向依赖关系:config A
     select B
     在A选项被选中的情况下，B选项自动被选中。
可选择性
    使用choice和endchoice定义可选择项
    直接举例说明:choice
                    bool "a"
                config b
                    bool b1
                config c
                    bool c1
                 endchoice
注释
    comment  在图像化界面显示一行注释
    Config TEST CONFIG
    bool "test“
    default y
    help
        just test
    comment "just test"
source
    读取另一个kconfig文件


1️⃣ 备份容器自身（当前状态）

你现在容器 luckfox 已退出（Exited），可以直接导出容器：

docker export luckfox -o ~/backup/luckfox_container_$(date +%F).tar


这个命令会把容器里的 文件系统状态打包成 tar 文件

注意：不会包含挂载的宿主机目录，只是容器内部生成的文件

恢复方式：

cat ~/backup/luckfox_container_2025-10-24.tar | docker import - luckfox_image_backup
docker run -it luckfox_image_backup /bin/bash

2️⃣ 备份挂载的宿主机目录

你容器挂载了 /home/guoyuge/luckfox-pico，里面存放了 SDK 数据，需要单独备份：

rsync -aAXv /home/guoyuge/luckfox-pico ~/backup/luckfox_pico_data_$(date +%F)


或者打包成 tar：

tar czpvf ~/backup/luckfox_pico_data_$(date +%F).tar.gz -C /home/guoyuge luckfox-pico


✅ 这样你就得到了：

容器镜像 → 包含容器内安装的 SDK、配置、编译环境

宿主机挂载目录 → 包含 SDK 生成的文件、数据

3️⃣ 恢复方法

假设你需要恢复：

# 导入容器
docker import ~/backup/luckfox_container_2025-10-24.tar - luckfox_image_restore

# 恢复挂载数据
tar xzpvf ~/backup/luckfox_pico_data_2025-10-24.tar.gz -C /home/guoyuge

# 运行容器并挂载
docker run -v /home/guoyuge/luckfox-pico:/home -it luckfox_image_restore /bin/bash


💡 总结策略：

容器状态 → docker export

挂载目录 → rsync 或 tar

两者合起来就完整备份了整个 SDK 环境，随时可以恢复，即使你改内核也不会丢数据。




6.驱动编译到内核   一定要进入容器操作
    字符文件
    进入内核文件 cd /home/guoyuge/luckfox-pico/sysdrv/source/kernel
    cd driver/ 驱动文件夹   cd char/ 进入字符设备
    mkdir helloworld 
    cd helloword
    touch kconfig
    vi kconfig
# HELLOWORLD 一定要大写 一定要大写 大写大写大写 
config HELLOWORLD   
    bool"helloworld support"
    default y
    help
        helloworld
    cd ../
    vim kconfig
    添加source ”driver/char/helloworld/kconifg“
    回到内核目录
    make menuconfig 检查是否成功
    cp .../helloworld.c  .放到 ”driver/char/helloworld/中
    编写makfile文件  打开内核目录（图像化界面） 检查helloworld  更具y还是n来确定 是否编译
    obj-$(CONFIG_HELLOWORLD)    :=helloworld.o
    修改上一级别的makefile文件 包含这个makefile
    obj-y            +=helloworld/
    1.编译看有有没有编译
    2.烧录到开发板上 看看有没有
    我们当前的.config已经更改了 我们需要把修改过的.config 生成默认的.config
    cp .config arch/arm/configs/rockchip_linux_defconfig 覆盖了默认配置
        进入容器进行操作
    容器 cd home
    用 ./build.sh kernelconfig    这个会cp  /home/sysdrv/source/kernel/arch/arm/configs/luckfox_rv1106_linux_defconfig  /home/sysdrv/source/kernel/.config
          ./build.sh kernelconfig  保存退出后 cp  /home/sysdrv/source/kernel/defconfig /home/sysdrv/source/kernel/arch/arm/configs/luckfox_rv1106_linux_defconfig
#   用vim查找添加的模块可以发现luckfox_rv1106_linux_defconfig并没有改变 其中没有添加的模块 vim  /home/sysdrv/source/kernel/.config 可以发现其中有添加的模块
#   所以  cp /home/sysdrv/source/kernel/.config \  
#          /home/sysdrv/source/kernel/arch/arm/configs/luckfox_rv1106_linux_defconfig

    ./build.sh kernel  编译
    下载到板子里用dmesg  查看日志 不一定可以查看到你打印的 因为可能不同的板子有的会屏蔽一些低级的日志
    [root@luckfox root]# cat /proc/kallsyms | grep helloworld_init
    b05f698c t helloworld_init
    为什么没卸载函数呢 因为没关机。
    /proc/kallsyms 是 Linux 内核提供的一个 内核符号表（kernel symbol table） 的虚拟文件，它记录了内核中所有已知函数和变量的地址、类型和名称。
    地址：比如 b05f698c，是这个符号在内核虚拟地址空间中的位置。
    类型：单个字母表示符号类型
        T：全局可访问的函数（text段）
        t：局部函数（text段）
        R：只读数据
        D：全局可写数据
        d：局部可写数据
    符号名：比如 helloworld_init，就是函数或变量的名字
    用途：
   1.确认内核模块是否被编译进内核
   2.查看某个函数的地址
   3. 调试内核或驱动


7.驱动模块传参数
    argc 传入参数的个数  argv 要传入的值 系统编程 
    module_param  传递基本类型函数  module_param_arry 数组类型函数  module_param_string 字符类型函数  icnlude/linux/moduleparm.h
    #define module_param(name, type, perm)  perm 参数的读写权限 在stat.h中定义  s_iugo  444 一般用这个
        module param named(name, name, type, perm)
    #define module param array(name, type, nump, perm) nump数组的长度
        module param array named(name, name, type, nump, perm)
    #define module param string(name, string, len, perm) string 驱动程序中变量的名字 要和name的名字保持一致 len字符串的大小
        static const struct kparam _string param string_ ##name= { len, string };
        ——module——param_call(MODULE PARAM PREFIX, name.&param ops string..str=& param string ##name, perm,-1, 0);MODULE PARM TYPE(name, "string")

    MODULE_PARM_DESC(_parm，desc) 帮助信息
        _parm: 要描述的参数的参数名称
        desc:描述信息
    /home/guoyuge/luckfox-pico/sysdrv/source/kernel/include  
    #include <linux/module.h>
    #include <linux/init.h>
    #include <linux/moduleparam.h>   传参头文件   
    有传参头文件用这三个
这个是rv1106上的makefile标准文件代码 编译模块应该直接用这个
# --- Makefile (方案B) ---
obj-m += a.o
# 内核源码目录（不是 buildroot 顶层）
KDIR := /home/guoyuge/luckfox-pico/sysdrv/source/kernel

ARCH := arm
CROSS_COMPILE := arm-rockchip830-linux-uclibcgnueabihf
PWD := $(shell pwd)

# O 目录：放构建产物（随便放哪都行，保持一致）
KBUILD_OUTPUT := $(abspath $(dir $(lastword $(KDIR))))/objs_kernel

all:
	$(MAKE) O=$(KBUILD_OUTPUT) -C $(KDIR) M=$(PWD) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE)- modules

clean:
	$(MAKE) O=$(KBUILD_OUTPUT) -C $(KDIR) M=$(PWD) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE)- clean

####    模块入口函数：static int __init moduleparam_init(void) ✅

    模块退出函数：static void __exit moduleparam_exit(void) ✅

    任何要在运行期继续使用的函数：不要加 __init / __exit。
### 新代码：优先 pr_*()；在驱动里更优先 dev_*()。 打印函数
*_emerg（最严重）
*_alert
*_crit
*_err
*_warn / *_warning（同义）
*_notice
*_info
*_debug（调试）


insmod param.ko a=7 array=8,9,10 str=world

8.内核模块符号导出

符号表：就是内核中的函数名 全局变量 等 用来 记录这些名字
#include <linux/export.h>  头文件
EXPORT_SYMBOL(符号名)  一般用这个  
EXPORT_SYMBOL_GPL(符号名) 只适合包含GPL许可的模块
到处去的可以被其他模块使用，使用前提前声明一下就行

a模块（a中要声明函数 #include <linux/export.h>
int add(int a, int b)
{
    return a + b;
}
EXPORT_SYMBOL(add);）
编译后 把Module.symvers 内容：KBUILD_EXTRA_SYMBOLS := /home/guoyuge/桌面/linux/a/Module.symvers  放在b文件夹、

b文件夹要在 makefile文件第一行加入KBUILD_EXTRA_SYMBOLS := /home/guoyuge/桌面/linux/a/Module.symvers
insmod a.ko
insmod b.ko a=3 b=5
dmesg | tail -n 20
#
lsmod                         # 列表（模块名  大小  被谁使用的次数/模块）
cat /proc/modules             # 与 lsmod 类似，原始格式
# 卸载模块（优先方法）
优先用 modprobe -r（会按依赖顺序移除）：
modprobe -r <模块名>            # 模块名不带 .ko，例如 modprobe -r b
不处理依赖、只强行卸载单个模块（谨慎）：
rmmod <模块名>

9.阶段总结
1.最简单驱动编写结构
2.驱动编译成模块 驱动编译进内核
3.基本类型参数 int arr string
4.内核模块符号表

10.编译进内核的驱动系统是如何运行的  没听懂 后面研究
module_init（6）原型在include/linux/module.h中   module_exit在编译进内核中的时候没有意义，因为静态编译的驱动无法卸载
查看头文件module.h发现MODULE是定义在kernel中的makefile文件中 mudlue是否定义走什么支路
打开makefile
moduel看是否定义
KBUILD_CPPFLAGS := -D__KERNEL__
KBUILD_AFLAGS_KERNEL :=
KBUILD_CFLAGS_KERNEL :=    如果编译进内核 module由这个变量决定
KBUILD_AFLAGS_MODULE  := -DMODULE
KBUILD_CFLAGS_MODULE  := -DMODULE  如果编译成ko module由这个变量决定
KBUILD_LDFLAGS_MODULE :=
KBUILD_LDFLAGS :=
CLANG_FLAGS :=
其他接口放在init.h中 其他借口和module——init操作时一样的  区别只是level 等级不一样 也就是优先级
在init.h 240行左右 带s的优先级小于不带s的优先级

11.如何让驱动更快的加载 先执行驱动A在执行驱动B
我们只需要把代码中的module_init（）换成比他优先级高就可以 例如arch_init()

12.驱动代码用makefile的宏
static int __init add_provider_init(void)
{
#ifndef DEBUG
    pr_info("Provider module loaded: hello a\n");
#else
    pr_info("Provider module loaded: hello b\n");
#endif
    return 0;
}
看这个DEBUG
如果编译成ko弄到板子上 会发现打印的是hello a 这是因为我们编译的时候使用的kernel中的makefile文件
KBUILD_CFLAGS_KERNEL :=    如果编译进内核 module由这个变量决定
KBUILD_CFLAGS_MODULE  := -DMODULE  如果编译成ko module由这个变量决定
我们现在编译的是ko文件所以 用 KBUILD_CFLAGS_MODULE 来定义驱动中的DEBUG
方法1:在makeflie文件中 最上面加一行 KBUILD_CFLAGS_MODULE += -DDEBUG
方法2：#define DEBUG 直接在代码中显示定义 例如 #define DEBUG 3 如果想实现这种效果
    在makeflie文件中 最上面加一行 KBUILD_CFLAGS_MODULE += -DDEBUG=3   同理 EXTRA_CFLAGS += -DDEBUG=3 也可以
法3：makeflie文件中 最上面加一行 EXTRA_CFLAGS += -DDEBUG
法4：#define DEBUG 直接在代码中显示定义 例如 #define DEBUG 3
主要区别总结：
特性	KBUILD_CFLAGS_MODULE	EXTRA_CFLAGS
适用范围	主要用于内核模块编译	可用于任何 C 项目，灵活性较高
构建系统集成	是内核构建系统的一部分，直接与内核构建工具链整合	独立于内核构建系统，可以用于独立的 C 项目或内核模块
目的	添加特定编译选项，和内核构建系统兼容	向 C 编译器添加编译选项，适用于多种编译场景
适用场景	内核模块开发，特别是在内核源代码树中	非内核项目或不依赖内核构建系统的模块开发
灵活性	较低，仅限于模块编译	高，可以自由定制编译选项，适用于各种 C 项目和编译环境
例子	KBUILD_CFLAGS_MODULE += -DDEBUG	EXTRA_CFLAGS += -DDEBUG

何时使用哪个？
使用 KBUILD_CFLAGS_MODULE：如果你正在进行 内核模块开发，并且需要与内核构建系统兼容，添加额外的编译选项（如启用调试、添加宏定义），你应该使用 KBUILD_CFLAGS_MODULE。它能够很好地与内核的构建环境和配置集成。
使用 EXTRA_CFLAGS：如果你需要更多的灵活性，或者模块的编译环境比较独立，不依赖于内核的构建系统，使用 EXTRA_CFLAGS 会更方便，特别是对于 跨平台编译 或 内核外部的 C 项目。

总结：
KBUILD_CFLAGS_MODULE 更适用于 内核模块开发，因为它能和内核构建系统集成，符合内核的编译规范。
EXTRA_CFLAGS 更适用于 跨项目编译，可以灵活控制编译器的选项，并且适用于内核模块之外的代码。
在内核模块开发中，如果不特别需要 KBUILD_CFLAGS_MODULE 的内核构建系统特性，EXTRA_CFLAGS 也能满足大多数需求。



启发：在我们在linux内核源码中找不到了某些宏或者变量的时，可以去makefile或者链接脚本中去找 思路要打开

13.内核时如何运行 ko文件的（视频找）
/home/guoyuge/luckfox-pico/sysdrv/source/buildroot/buildroot-2023.02.6/output/build/busybox-1.36.1/modutils/insmod.c
luckfox-pico/sysdrv/source/buildroot/buildroot-2023.02.6/output/build/busybox-1.36.1/modutils/modutils.c（bb_init_ 其中有两种方法）
1.直接用ko insmod
2.寻找地址内存
其中加入 dump_stack();//打印调用关系函数 也就是调用打印信息 我们传到开发板中
insmod一下 然后  dmesg 
[  524.709925] CPU: 0 PID: 3280 Comm: insmod Tainted: G           O      5.10.160 #1
[  524.709950] Hardware name: Generic DT based system
[  524.709985] [<b000f56d>] (unwind_backtrace) from [<b000e03f>] (show_stack+0xb/0xc)
[  524.710007] [<b000e03f>] (show_stack) from [<af803007>] (helloworld_init+0x7/0x14 [helloworld])
[  524.710029] [<af803007>] (helloworld_init [helloworld]) from [<b00096eb>] (do_one_initcall+0x43/0xf0)
[  524.710048] [<b00096eb>] (do_one_initcall) from [<b00417e3>] (do_init_module+0x27/0x120)
[  524.710064] [<b00417e3>] (do_init_module) from [<b0042b97>] (load_module+0x1223/0x13d4)
[  524.710078] [<b0042b97>] (load_module) from [<b0042e47>] (sys_finit_module+0x53/0x5c)
[  524.710094] [<b0042e47>] (sys_finit_module) from [<b0008201>] (ret_fast_syscall+0x1/0x58)
[  524.710102] Exception stack(0xb1c7ffa8 to 0xb1c7fff0)
[  524.710115] ffa0:                   8413016c aed49e76 00000003 005b2008 00000000 aed49e76
[  524.710126] ffc0: 8413016c aed49e76 aed49d64 0000017b 00000003 00000000 005b09dc 00000000
[  524.710135] ffe0: aed49bc8 aed49bb8 004f67d8 a6e9f8b0
[  524.710140] helloworld!

我们可以看到用的是sys_finit_module 也就是方法一
自己写一个自己insmod命令 用方法一  代码中有
方法二 我也写代码里了

[ 8066.968597] CPU: 0 PID: 1034 Comm: myinsmod Tainted: G           O      5.10.160 #1
[ 8066.968624] Hardware name: Generic DT based system
[ 8066.968656] [<b000f56d>] (unwind_backtrace) from [<b000e03f>] (show_stack+0xb/0xc)
[ 8066.968677] [<b000e03f>] (show_stack) from [<af807007>] (helloworld_init+0x7/0x14 [helloworld])
[ 8066.968701] [<af807007>] (helloworld_init [helloworld]) from [<b00096eb>] (do_one_initcall+0x43/0xf0)
[ 8066.968720] [<b00096eb>] (do_one_initcall) from [<b00417e3>] (do_init_module+0x27/0x120)
[ 8066.968738] [<b00417e3>] (do_init_module) from [<b0042b97>] (load_module+0x1223/0x13d4)
[ 8066.968754] [<b0042b97>] (load_module) from [<b0042e47>] (sys_finit_module+0x53/0x5c)
[ 8066.968770] [<b0042e47>] (sys_finit_module) from [<b0008201>] (ret_fast_syscall+0x1/0x58)
[ 8066.968778] Exception stack(0xb0a9bfa8 to 0xb0a9bff0)
[ 8066.968791] bfa0:                   00000002 00000000 00000003 000105d0 00000000 ae918d64
[ 8066.968802] bfc0: 00000002 00000000 00000003 0000017b 00000000 00000000 a6ff4f70 ae918c1c
[ 8066.968811] bfe0: ae918c08 ae918bf8 00010538 a6f618b0
[ 8066.968815] helloworld!

可以看出来代码二中用的是 sys_init_module
[17219.710054] CPU: 0 PID: 443 Comm: myinsmod Tainted: G           O      5.10.160 #1
[17219.710080] Hardware name: Generic DT based system
[17219.710112] [<b000f56d>] (unwind_backtrace) from [<b000e03f>] (show_stack+0xb/0xc)
[17219.710135] [<b000e03f>] (show_stack) from [<af813007>] (helloworld_init+0x7/0x14 [helloworld])
[17219.710159] [<af813007>] (helloworld_init [helloworld]) from [<b00096eb>] (do_one_initcall+0x43/0xf0)
[17219.710177] [<b00096eb>] (do_one_initcall) from [<b00417e3>] (do_init_module+0x27/0x120)
[17219.710192] [<b00417e3>] (do_init_module) from [<b0042b97>] (load_module+0x1223/0x13d4)
[17219.710205] [<b0042b97>] (load_module) from [<b0042ded>] (sys_init_module+0xa5/0xac)
[17219.710221] [<b0042ded>] (sys_init_module) from [<b0008201>] (ret_fast_syscall+0x1/0x58)
[17219.710229] Exception stack(0xb1c5ffa8 to 0xb1c5fff0)
[17219.710240] ffa0:                   00000002 0000000e 00022008 000133f4 00010928 aed0ed64
[17219.710252] ffc0: 00000002 0000000e 00000000 00000080 00000000 00000000 a6fc6f70 aed0ec1c
[17219.710262] ffe0: aed0eb98 aed0eb88 000108ac a6f338b0
[17219.710267] helloworld!
[root@luckfox ]#

# 14.系统调用（视频）
操作系统提供的接口 
客户 上层应用 
服务员 系统调用
厨师  硬件
init_module 和 finit_module 这就是两个系统调用
syscall 可以来系统调用
根据系统调用号，调用相应的系统调用

_NR_init_module和谁绑定了呢？iCloude/uapi/sam-generic/unistd.h 文件
init_module应用 sys_init_module系统


# 15.向系统中添加一个系统调用
1.在内核源码中添加自己的服务，需要编译进内核（编写helloworld.c文件）
2.添加系统调用号
3.编译并烧写内核到开发板

系统调用原型定义文件地址
/home/guoyuge/luckfox-pico/sysdrv/source/kernel/include/linux/syscalls.h

#ifndef SYSCALL_DEFINE0
#define SYSCALL_DEFINE0(sname)					\
	SYSCALL_METADATA(_##sname, 0);				\
	asmlinkage long sys_##sname(void);			\
	ALLOW_ERROR_INJECTION(sys_##sname, ERRNO);		\
	asmlinkage long sys_##sname(void)
#endif /* SYSCALL_DEFINE0 */

#define SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(1, _##name, __VA_ARGS__)
#define SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__)
#define SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)
#define SYSCALL_DEFINE4(name, ...) SYSCALL_DEFINEx(4, _##name, __VA_ARGS__)
#define SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__)
#define SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(6, _##name, __VA_ARGS__)

如果系统调用是三个参数 那就用SYSCALL_DEFINE3  后面数字是几个参数就用几个，没有带参数就用数字0的
这次的helloworld.c文件可以放在linux源码的任意路径下

#include<linux/kernel.h>
#include<linux/syscalls.h>

SYSCALL_DEFINE0(helloworld){

    printk("this is hellowrold syscall\n");
    return 0;
}

添加系统调用号 应该在unistd.h文件中对应
/home/guoyuge/luckfox-pico/sysdrv/source/kernel/include/uapi/asm-generic/unistd.h
在这个文件中添加系统调用号
#define __NR_process_mrelease 448
__SYSCALL(__NR_process_mrelease, sys_process_mrelease)

# #define __NR_helloworld 449
__SYSCALL(__NR_helloworld, sys_helloworld)

#undef __NR_syscalls
#define __NR_syscalls 450
然后需要修改
/home/guoyuge/luckfox-pico/sysdrv/source/kernel/arch/arm/tools/syscall.tbl
中的最后一行添加
449 common  helloworld      sys_helloworld

接下来重复 ##驱动编译到内核##

然后写测试程序

用交叉编译编译好之后 传达板子是就可以


#####  然后经过我的思考 我发现 只修改 然后需要修改
#### /home/guoyuge/luckfox-pico/sysdrv/source/kernel/arch/arm/tools/syscall.tbl
### 中的最后一行添加
#### 449 common  helloworld      sys_helloworld

然后编译烧录也可以 
# gpt 说 ✅ 只改 syscall.tbl + 实现 SYSCALL_DEFINE... + 重新编内核/刷机 → 就能用

###   ❌ 不要改 include/uapi/asm-generic/unistd.h（那是通用模板，ARM 实际不吃它）



# 什么是内核态 什么是用户态 两个代码编译的时候用不同的编译器 

| 层级                    | 代码运行的地方   | 举例                           | 是否能用标准C库（`stdio.h`、`printf`） |
| --------------------- | --------- | ---------------------------- | ---------------------------- |
| **内核态（Kernel space）** | 内核空间，最高权限 | 内核本身、驱动、系统调用实现               | ❌ 不能                         |
| **用户态（User space）**   | 普通程序运行空间  | `ls`, `bash`, `cat`, 你写的应用程序 | ✅ 可以                         |

下面是一个外部内核模块的Makefile文件 是通用的 编译出来的结果是.ko文件

# --- Makefile (方案B) ---
obj-m += syscall.o  //只需要更改这个就可以

# 内核源码目录（不是 buildroot 顶层）
KDIR := /home/guoyuge/luckfox-pico/sysdrv/source/kernel

ARCH := arm
CROSS_COMPILE := arm-rockchip830-linux-uclibcgnueabihf
PWD := $(shell pwd)

# O 目录：放构建产物（随便放哪都行，保持一致）
KBUILD_OUTPUT := $(abspath $(dir $(lastword $(KDIR))))/objs_kernel

all:
	$(MAKE) O=$(KBUILD_OUTPUT) -C $(KDIR) M=$(PWD) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE)- modules

clean:
	$(MAKE) O=$(KBUILD_OUTPUT) -C $(KDIR) M=$(PWD) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE)- clean

下面是用户态
命令行：
export PATH=/home/ubuntu/luckfox-pico/gcc-arm-11.2-2022.02-x86_64-arm-none-linux-gnueabihf/bin:$PATH
arm-rockchip830-linux-uclibcgnueabihf-gcc hello.c -o hello

makefile
#Luckfox-pico-ultra-w-ubuntu
CC := /home/ubuntu/luckfox-pico/gcc-arm-11.2-2022.02-x86_64-arm-none-linux-gnueabihf/bin/arm-none-linux-gnueabihf-gcc

hello:hello.c
    -$(CC) $^ -o $@
编译出来的是可执行文件 不是.KO文件


# 16   加载ko文件总结  (具体看视频)
当insmode 会执行  init_module 或者 finit_module   然后这两个会执行 load_module（加载的核心函数）

load_module 会执行do_init_module

init_module是执行加载程序的同意别名 

# 内核时如何加载KO文件的 
 1. 通过insmod命令调用系统finit_module或init_module
    1.通过写一个自己的insmod命令认识并学习了系统调用finit_module或者init_module
    2.了解了系统调用的流程并向内核添加了一个自己的系统调用
 2. 内核执行sys_finit_module或者sys_init_module函数
    最终都会调用load_moudle -> do_init_module -> do_one_initcall(mod -> init)
    来执行驱动的入口函数。
    struct_module结构体会链接到ko文件中，在加载驱动的时候，内核里面会将这个结构体解析出来，并根据这个结构体加载驱动。




    

